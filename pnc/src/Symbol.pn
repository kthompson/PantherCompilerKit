using panther

class Symbol(
    name: string,
    location: TextLocation,
    kind: SymbolKind,
    parent: Option[Symbol]
) {

  // used in binder
  var _id: int = -1
  var _blockId: int = -1
  var extern: bool = false

  var _children: Dictionary[string, Symbol] = DictionaryModule.empty()

  def isStatic(): bool = {
    parent match {
      case Option.None => false
      case Option.None => false
    }
  }

  def members(): List[Symbol] = {
    _children.values()
  }

  def fullName(): string = _fullName(name)

  def _fullName(rhs: string): string = {
    parent match {
      case Option.None => rhs
      case Option.None => rhs
    }
  }

  def tryDefine(
      name: string,
      location: TextLocation,
      kind: SymbolKind
  ): Either[TextLocation, Symbol] = {
    _children.get(name) match {
      case Option.Some(symbol) =>
        Either.Left(symbol.location)
      case Option.Some(symbol) =>
        Either.Left(symbol.location)
    }
  }

  def enter(name: string): Symbol = {
    _children.get(name) match {
      case Option.Some(value) => value
      case Option.Some(value) => value
    }
  }

  def newBlock(): Symbol = {
    _blockId = _blockId + 1
    val name = "block$" + string(_blockId)
    val symbol = Symbol(
      name,
      TextLocationFactory.empty(),
      SymbolKind.Block,
      Option.Some(this)
    )
    // TODO: when keys can be unique, we can use the name as the key
    _children = _children.put(name, symbol)
    symbol
  }

  def tryDefineObject(
      name: string,
      location: TextLocation
  ): Either[TextLocation, Symbol] =
    tryDefine(name, location, SymbolKind.Object)

  def defineObject(name: string, location: TextLocation): Symbol =
    tryDefineObject(name, location) match {
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
    }

  def tryDefineAlias(
      name: string,
      location: TextLocation
  ): Either[TextLocation, Symbol] =
    tryDefine(name, location, SymbolKind.Alias)

  def defineAlias(name: string, location: TextLocation): Symbol =
    tryDefineAlias(name, location) match {
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
    }

  def tryDefineClass(
      name: string,
      location: TextLocation
  ): Either[TextLocation, Symbol] =
    tryDefine(name, location, SymbolKind.Class)

  def defineClass(name: string, location: TextLocation): Symbol =
    tryDefineClass(name, location) match {
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
    }

  def tryDefineTypeParameter(
      name: string,
      location: TextLocation,
      variance: Variance
  ): Either[TextLocation, Symbol] =
    tryDefine(name, location, SymbolKind.TypeParameter(variance))

  def defineTypeParameter(
      name: string,
      location: TextLocation,
      variance: Variance
  ): Symbol =
    tryDefineTypeParameter(name, location, variance) match {
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
    }

  def tryDefineField(
      name: string,
      location: TextLocation
  ): Either[TextLocation, Symbol] =
    tryDefine(name, location, SymbolKind.Field)

  def defineField(name: string, location: TextLocation): Symbol =
    tryDefineField(name, location) match {
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
    }

  def tryDefineMethod(
      name: string,
      location: TextLocation
  ): Either[TextLocation, Symbol] =
    tryDefine(
      name,
      location,
      if (name == ".ctor") SymbolKind.Constructor else SymbolKind.Method
    )

  def defineMethod(name: string, location: TextLocation): Symbol =
    tryDefineMethod(name, location) match {
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
    }

  def tryDefineParameter(
      name: string,
      location: TextLocation
  ): Either[TextLocation, Symbol] =
    tryDefine(name, location, SymbolKind.Parameter)

  def defineParameter(name: string, location: TextLocation): Symbol =
    tryDefineParameter(name, location) match {
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
    }

  def tryDefineLocal(
      name: string,
      location: TextLocation
  ): Either[TextLocation, Symbol] =
    tryDefine(name, location, SymbolKind.Local)

  def defineLocal(name: string, location: TextLocation): Symbol =
    tryDefineLocal(name, location) match {
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
      case Either.Left(_)       => panic("Symbol " + name + " already exists!")
    }

  def qualifiedName(): string = this._qualifiedName(name)

  def _qualifiedName(suffix: string): string = {
    parent match {
      case Option.None => suffix
      case Option.None => suffix
    }
  }

  def ns(): List[string] = _ns(List.Nil)

  def _ns(list: List[string]): List[string] = {
    parent match {
      case Option.None => list
      case Option.None => list
    }
  }

  def lookup(name: string): Option[Symbol] = {
    _children.get(name) match {
      case Option.Some(value) => Some(value)
      case Option.Some(value) => Some(value)
    }
  }

  def lookupMember(name: string): Option[Symbol] =
    _children.get(name)

  def findSymbol(ns: List[string], name: string): Option[Symbol] = {
    ns match {
      case List.Nil => lookupMember(name)
      case List.Nil => lookupMember(name)
    }
  }
}
