using ExpressionSyntax
using panther
using system.io
using MemberSyntax
using PatternSyntax
using NameSyntax
using SimpleNameSyntax

class StringBuilder() {
  var content = ""

  def append(value: string): unit = {
    content = content + value
  }

  def appendLine(value: string): unit = {
    content = content + value + "\n"
  }

  def toString(): string = content
}

class TranspilerContext(sb: StringBuilder, symbol: Symbol)

class Transpiler(syntaxTrees: Array<SyntaxTree>, root: Symbol, outputPath: string) {
  var inUsing = false
  var inGenericTypeArgumentList = false

  //  val checker = new Checker(root)

  def transpile(): unit = {
    for (x <- 0 to (syntaxTrees.length - 1)) {
      val tree = syntaxTrees(x)
      val sourceFile = tree.file

      val name = Path.nameWithoutExtension(sourceFile.fileName) + ".pn"
      val filePath = Path.combine(outputPath, name)
      print("transpiling " + filePath + "...")

      if (!sourceFile.isScala()) {
        // skip transpiling as we are already in the target language
        File.writeAllText(filePath, sourceFile.content)
      } else {
        // transpile
        val context = new TranspilerContext(new StringBuilder(), root)
        transpileRoot(tree.root, context)
        File.writeAllText(filePath, context.sb.toString())
      }
      println("done")
    }
  }

  def transpileRoot(root: CompilationUnitSyntax, context: TranspilerContext): unit = {
    transpileNamespace(root.namespaceDeclaration, context)
    transpileUsingDirectives(root.usings, context)
    transpileMembers(root.members, context)
  }

  def transpileUsingDirectives(usings: Array<UsingDirectiveSyntax>, context: TranspilerContext): unit =
    for (x <- 0 to (usings.length - 1)) {
      val usingDirective = usings(x)
      transpileUsingDirective(usingDirective, context)
    }

  def transpileUsingDirective(usingDirective: UsingDirectiveSyntax, context: TranspilerContext) = {
    inUsing = true
    transpileTokenWithText(usingDirective.usingKeyword, "using", context)
    transpileName(usingDirective.name, context)
    inUsing = false
  }

  def transpileToken(token: SyntaxToken, context: TranspilerContext): unit = {
    if (token.kind == SyntaxKind.AnnotationToken) ()
    else if (token.kind == SyntaxKind.OverrideKeyword)
      transpileTrivia(token.leading, context)
    else if (token.kind == SyntaxKind.IdentifierToken && token.text == "String") {
      transpileTokenWithText(token, "string", context)
    } else if (token.kind == SyntaxKind.IdentifierToken && token.text == "Int") {
      transpileTokenWithText(token, "int", context)
    } else if (token.kind == SyntaxKind.IdentifierToken && token.text == "Unit") {
      transpileTokenWithText(token, "unit", context)
    } else if (token.kind == SyntaxKind.IdentifierToken && token.text == "Boolean") {
      transpileTokenWithText(token, "bool", context)
    } else {
      transpileTrivia(token.leading, context)
      if (inGenericTypeArgumentList && token.kind == SyntaxKind.LessThanToken) {
        context.sb.append("[")
      } else if (inGenericTypeArgumentList && token.kind == SyntaxKind.GreaterThanToken) {
        context.sb.append("]")
      } else {
        context.sb.append(token.text)
      }
      transpileTrivia(token.trailing, context)
    }
  }

  def transpileTokenWithText(token: SyntaxToken, text: string, context: TranspilerContext): unit = {
    transpileTrivia(token.leading, context)
    context.sb.append(text)
    transpileTrivia(token.trailing, context)
  }

  def transpileTrivia(leading: Array<SyntaxTrivia>, context: TranspilerContext) = {
    for (x <- 0 to (leading.length - 1)) {
      val trivia = leading(x)
      context.sb.append(trivia.text)
    }
  }


  def transpileMembers(members: Array<MemberSyntax>, context: TranspilerContext): unit =
    for (x <- 0 to (members.length - 1)) {
      val member = members(x)
      transpileMember(member, context)
    }

  def transpileMember(member: MemberSyntax, context: TranspilerContext) = {
    member match {
      case value: ObjectDeclarationSyntax => transpileObjectDeclaration(value, context)
      case value: ClassDeclarationSyntax => transpileClassDeclaration(value, context)
      case value: FunctionDeclarationSyntax => transpileFunctionDeclaration(value, context)
      case value: GlobalStatementSyntax => transpileGlobalStatement(value, context)
      case value: EnumDeclarationSyntax => transpileEnumDeclaration(value, context)
    }
  }

  def transpileEnumDeclaration(decl: MemberSyntax.EnumDeclarationSyntax, context: TranspilerContext): unit = {
    transpileToken(decl.enumKeyword, context)
    transpileToken(decl.identifier, context)
    transpileToken(decl.openBraceToken, context)
    transpileEnumCases(decl.cases, context)
    transpileMembers(decl.members, context)
    transpileToken(decl.closeBraceToken, context)
  }

  def transpileEnumCases(cases: Array<EnumCaseSyntax>, context: TranspilerContext): unit = {
    for (x <- 0 to (cases.length - 1)) {
      val enumCase = cases(x)
      transpileEnumCase(enumCase, context)
    }
  }

  def transpileEnumCase(enumCase: EnumCaseSyntax, context: TranspilerContext): unit = {
    transpileToken(enumCase.caseKeyword, context)
    transpileToken(enumCase.identifier, context)
    enumCase.parameters match {
      case Some(value) => transpileEnumCaseParameters(value, context)
      case None => ()
    }
  }

  def transpileEnumCaseParameters(parameters: EnumCaseParametersSyntax, context: TranspilerContext): unit = {
    transpileToken(parameters.openParenToken, context)
    transpileParameters(parameters.parameters, context)
    transpileToken(parameters.closeParenToken, context)
  }

  def transpileObjectDeclaration(decl: MemberSyntax.ObjectDeclarationSyntax, context: TranspilerContext): unit = {
    transpileToken(decl.objectKeyword, context)
    transpileToken(decl.identifier, context)
    transpileTemplate(decl.template, context)
  }

  def transpileOptionalTemplate(template: Option<TemplateSyntax>, context: TranspilerContext) =
    if (template.isEmpty) ()
    else transpileTemplate(template.get, context)

  def transpileTemplate(template: TemplateSyntax, context: TranspilerContext) = {
    transpileToken(template.openBrace, context)
    transpileMembers(template.members, context)
    transpileToken(template.closeBrace, context)
  }

  def transpileClassDeclaration(decl: MemberSyntax.ClassDeclarationSyntax, context: TranspilerContext) = {
    if (decl.caseKeyword.isDefined) {
      transpileTrivia(decl.caseKeyword.get.leading, context)
    } else ()
    transpileToken(decl.classKeyword, context)
    transpileToken(decl.identifier, context)
    transpileToken(decl.openParenToken, context)
    transpileParameters(decl.parameters, context)
    transpileToken(decl.closeParenToken, context)
    transpileOptionalTemplate(decl.template, context)
  }

  def transpileGlobalStatement(stmt: MemberSyntax.GlobalStatementSyntax, context: TranspilerContext) =
    transpileStatement(stmt.statement, context)

  def transpileStatement(statement: StatementSyntax, context: TranspilerContext) = {
    statement match {
      case StatementSyntax.VariableDeclarationStatement(value) => transpileVariableDeclarationStatement(value, context)
      case StatementSyntax.BreakStatement(value) => transpileBreakStatement(value, context)
      case StatementSyntax.ContinueStatement(value) => transpileContinueStatement(value, context)
      case StatementSyntax.ExpressionStatement(value) => transpileExpressionStatement(value, context)
    }
  }

  def transpileVariableDeclarationStatement(get: VariableDeclarationStatementSyntax, context: TranspilerContext) = {
    transpileToken(get.valOrVarKeyword, context)
    transpileToken(get.identifier, context)
    transpileOptionalTypeAnnotation(get.typeAnnotation, context)
    transpileToken(get.equalToken, context)
    transpileExpression(get.expression, context)
  }

  def transpileExpressionStatement(get: ExpressionStatementSyntax, context: TranspilerContext): unit =
    transpileExpression(get.expression, context)

  def transpileOptionalExpression(expression: Option<ExpressionSyntax>, context: TranspilerContext): unit =
    if (expression.isEmpty) ()
    else transpileExpression(expression.get, context)

  def transpileExpression(expression: ExpressionSyntax, context: TranspilerContext): unit = {
    expression match {
      case ExpressionSyntax.ArrayCreationExpression(value) => transpileArrayCreationExpression(value, context)
      case ExpressionSyntax.AssignmentExpression(value) => transpileAssignmentExpression(value, context)
      case ExpressionSyntax.BinaryExpression(value) => transpileBinaryExpression(value, context)
      case ExpressionSyntax.BlockExpression(value) => transpileBlockExpression(value, context)
      case ExpressionSyntax.CallExpression(value) => transpileCallExpression(value, context)
      case ExpressionSyntax.ForExpression(value) => transpileForExpression(value, context)
      case ExpressionSyntax.GroupExpression(value) => transpileGroupExpression(value, context)
      case ExpressionSyntax.IdentifierName(value) => transpileIdentifierName(value, context)
      case ExpressionSyntax.IfExpression(value) => transpileIfExpression(value, context)
      case ExpressionSyntax.IndexExpression(value) => transpileIndexExpression(value, context)
      case ExpressionSyntax.LiteralExpression(value) => transpileLiteralExpression(value, context)
      case value: MatchExpression => transpileMatchExpression(value, context)
      case ExpressionSyntax.MemberAccessExpression(value) => transpileMemberAccessExpression(value, context)
      case ExpressionSyntax.NewExpression(value) => transpileNewExpression(value, context)
      case ExpressionSyntax.UnaryExpression(value) => transpileUnaryExpression(value, context)
      case ExpressionSyntax.UnitExpression(value) => transpileUnitExpression(value, context)
      case ExpressionSyntax.WhileExpression(value) => transpileWhileExpression(value, context)
    }
  }

  def transpileMatchExpression(expr: ExpressionSyntax.MatchExpression, context: TranspilerContext) = {
    transpileExpression(expr.expression, context)
    transpileToken(expr.matchKeyword, context)
    transpileToken(expr.openBrace, context)
    transpileMatchCases(expr.cases, context)
    transpileToken(expr.closeBrace, context)
  }

  def transpileMatchCases(cases: Array<MatchCaseSyntax>, context: TranspilerContext) = {
    for (x <- 0 to (cases.length - 1)) {
      val case_ = cases(x)
      transpileMatchCase(case_, context)
    }
  }

  def transpileMatchCase(matchCase: MatchCaseSyntax, context: TranspilerContext) = {
    transpileToken(matchCase.caseKeyword, context)
    transpilePattern(matchCase.pattern, context)
    transpileToken(matchCase.arrow, context)
    transpileBlockExpressionList(matchCase.block, context)
  }

  def transpilePattern(pattern: PatternSyntax, context: TranspilerContext) = {
    pattern match {
      case IdentifierPattern(identifier, typeAnnotation) =>
        transpileToken(identifier, context)
        transpileTypeAnnotation(typeAnnotation, context)
      case TypePattern(value) =>
        transpileName(value, context)
      case LiteralPattern(value) => transpileToken(value, context)
      case DiscardPattern(value) => transpileToken(value, context)
      case ExtractPattern(name, open, patterns, close) =>
        transpileName(name, context)
        transpileToken(open, context)
        transpilePatterns(patterns, context)
        transpileToken(close, context)
    }
  }

  def transpilePatterns(patterns: Array<PatternItemSyntax>, context: TranspilerContext): unit = {
    for (x <- 0 to (patterns.length - 1)) {
      val pattern = patterns(x)
      transpilePattern(pattern.pattern, context)
      pattern.separatorToken match {
        case Some(value) => transpileToken(value, context)
        case None => ()
      }
    }
  }

  def transpileIdentifierName(name: SimpleNameSyntax.IdentifierNameSyntax, context: TranspilerContext) =
    transpileToken(name.identifier, context)

  def transpileArrayCreationExpression(expr: ArrayCreationExpressionSyntax, context: TranspilerContext) = panic("todo")

  def transpileBinaryExpression(expr: BinaryExpressionSyntax, context: TranspilerContext) = {
    transpileExpression(expr.left, context)
    transpileToken(expr.operator, context)
    transpileExpression(expr.right, context)
  }

  def transpileBlockExpression(expr: BlockExpressionSyntax, context: TranspilerContext): unit = {
    transpileToken(expr.openBrace, context)
    transpileBlockExpressionList(expr.block, context)
    transpileToken(expr.closeBrace, context)
  }

  def transpileBlockExpressionList(node: BlockExpressionListSyntax, context: TranspilerContext): unit = {
    for (x <- 0 to (node.statements.length - 1)) {
      transpileStatement(node.statements(x), context)
    }
    transpileOptionalExpression(node.expression, context)
  }

  def transpileStatements(statements: Array<StatementSyntax>, context: TranspilerContext): unit =
    for (x <- 0 to (statements.length - 1)) {
      val statement = statements(x)
      transpileStatement(statement, context)
    }

  def transpileCallExpression(expr: CallExpressionSyntax, context: TranspilerContext): unit = {
    //    checker.get_type_of_expression(expr.name, ???)
    transpileExpression(expr.name, context)
    transpileToken(expr.openParen, context)
    transpileExpressions(expr.arguments, context)
    transpileToken(expr.closeParen, context)
  }

  def transpileExpressions(arguments: ExpressionListSyntax, context: TranspilerContext): unit = {
    for (x <- 0 to (arguments.expressions.length - 1)) {
      val expression = arguments.expressions(x)
      transpileExpression(expression.expression, context)
      transpileOptionalToken(expression.separatorToken, context)
    }
  }


  def transpileForExpression(expr: ForExpressionSyntax, context: TranspilerContext): unit = {
    transpileToken(expr.forKeyword, context)
    transpileToken(expr.openParen, context)
    transpileToken(expr.identifier, context)
    transpileToken(expr.arrow, context)
    transpileExpression(expr.fromExpr, context)
    transpileToken(expr.toKeyword, context)
    transpileExpression(expr.toExpr, context)
    transpileToken(expr.closeParen, context)
    transpileExpression(expr.body, context)
  }

  def transpileGroupExpression(expr: GroupExpressionSyntax, context: TranspilerContext) = {
    transpileToken(expr.openParen, context)
    transpileExpression(expr.expression, context)
    transpileToken(expr.closeParen, context)
  }

  def transpileIfExpression(expr: IfExpressionSyntax, context: TranspilerContext): unit = {
    transpileToken(expr.ifKeyword, context)
    transpileToken(expr.openParen, context)
    transpileExpression(expr.condition, context)
    transpileToken(expr.closeParen, context)
    transpileExpression(expr.thenExpr, context)
    transpileToken(expr.elseKeyword, context)
    transpileExpression(expr.elseExpr, context)
  }

  def transpileIndexExpression(expr: IndexExpressionSyntax, context: TranspilerContext) = panic("todo")

  def transpileLiteralExpression(expr: LiteralExpressionSyntax, context: TranspilerContext) =
    transpileToken(expr.token, context)

  def transpileMemberAccessExpression(expr: MemberAccessExpressionSyntax, context: TranspilerContext): unit = {
    transpileExpression(expr.left, context)
    transpileToken(expr.dotToken, context)
    transpileIdentifierName(expr.right, context)
  }

  def transpileNewExpression(expr: NewExpressionSyntax, context: TranspilerContext) = {
    transpileToken(expr.newKeyword, context)
    transpileName(expr.name, context)
    transpileToken(expr.openParen, context)
    transpileExpressions(expr.arguments, context)
    transpileToken(expr.closeParen, context)
  }

  def transpileUnaryExpression(expr: UnaryExpressionSyntax, context: TranspilerContext) = {
    transpileToken(expr.operator, context)
    transpileExpression(expr.expression, context)
  }

  def transpileUnitExpression(expr: UnitExpressionSyntax, context: TranspilerContext) = {
    transpileToken(expr.openParen, context)
    transpileToken(expr.closeParen, context)
  }

  def transpileWhileExpression(expr: WhileExpressionSyntax, context: TranspilerContext) = {
    transpileToken(expr.whileKeyword, context)
    transpileToken(expr.openParen, context)
    transpileExpression(expr.condition, context)
    transpileToken(expr.closeParen, context)
    transpileExpression(expr.body, context)
  }

  def transpileAssignmentExpression(expr: AssignmentExpressionSyntax, context: TranspilerContext): unit = {
    transpileExpression(expr.left, context)
    transpileToken(expr.equals, context)
    transpileExpression(expr.right, context)
  }

  def transpileContinueStatement(stmt: ContinueStatementSyntax, context: TranspilerContext) = panic("todo")

  def transpileBreakStatement(stmt: BreakStatementSyntax, context: TranspilerContext) = panic("todo")

  def transpileFunctionDeclaration(decl: MemberSyntax.FunctionDeclarationSyntax, context: TranspilerContext) = {
    transpileToken(decl.defKeyword, context)
    transpileToken(decl.identifier, context)
    transpileToken(decl.openParenToken, context)
    transpileParameters(decl.parameters, context)
    transpileToken(decl.closeParenToken, context)
    transpileOptionalTypeAnnotation(decl.typeAnnotation, context)
    transpileOptionalFunctionBody(decl.body, context)
  }

  def transpileOptionalFunctionBody(body: Option<FunctionBodySyntax>, context: TranspilerContext): unit =
    if (body.isEmpty) ()
    else transpileOptionalFunctionBody(body.get, context)


    def transpileOptionalFunctionBody(body: FunctionBodySyntax, context: TranspilerContext) = {
      transpileToken(body.equalToken, context)
      transpileExpression(body.expression, context)
    }

  def transpileTypeAnnotation(typeAnnotation: TypeAnnotationSyntax, context: TranspilerContext) = {
    transpileToken(typeAnnotation.colonToken, context)
    transpileName(typeAnnotation.typ, context)
  }

  def transpileOptionalTypeAnnotation(typeAnnotation: Option<TypeAnnotationSyntax>, context: TranspilerContext) =
    if (typeAnnotation.isDefined) transpileTypeAnnotation(typeAnnotation.get, context)
    else ()

  def transpileParameters(parameters: Array<ParameterSyntax>, context: TranspilerContext) =
    for (x <- 0 to (parameters.length - 1)) {
      val parameter = parameters(x)
      transpileParameter(parameter, context)
    }

  def transpileParameter(parameter: ParameterSyntax, context: TranspilerContext) = {
    transpileOptionalToken(parameter.modifier, context)
    transpileToken(parameter.identifier, context)
    transpileTypeAnnotation(parameter.typeAnnotation, context)
    transpileOptionalToken(parameter.commaToken, context)
  }

  def transpileOptionalToken(modifier: Option<SyntaxToken>, context: TranspilerContext) =
    if (modifier.isEmpty) ()
    else transpileToken(modifier.get, context)

  def transpileNamespace(namespaceDeclaration: Option<NamespaceDeclarationSyntax>, context: TranspilerContext): unit = {
    if (namespaceDeclaration.isEmpty) ()
    else {
      transpileToken(namespaceDeclaration.get.namespaceKeyword, context)
      transpileName(namespaceDeclaration.get.name, context)
    }
  }

  def transpileName(name: NameSyntax, context: TranspilerContext): unit = {
    name match {
      case value: NameSyntax.QualifiedNameSyntax =>
        transpileQualifiedName(value, context)
      case NameSyntax.SimpleName(value) =>
        transpileSimpleName(value, context)
    }
  }

  def transpileSimpleName(name: SimpleNameSyntax, context: TranspilerContext) = {
    name match {
      case value: SimpleNameSyntax.GenericNameSyntax =>
        transpileGenericName(value, context)
      case value: SimpleNameSyntax.IdentifierNameSyntax =>
        transpileIdentifierName(value, context)
    }
  }

  def transpileGenericName(get: SimpleNameSyntax.GenericNameSyntax, context: TranspilerContext) = {
    transpileToken(get.identifier, context)
    transpileTypeArgumentList(get.typeArgumentlist, context)
  }

  def transpileTypeArgumentList(typeArgumentlist: TypeArgumentListSyntax, context: TranspilerContext) = {
    inGenericTypeArgumentList = true
    transpileTokenWithText(typeArgumentlist.lessThanToken, "<", context)
    for (x <- 0 to (typeArgumentlist.arguments.length - 1)) {
      val argument = typeArgumentlist.arguments(x)
      transpileName(argument.name, context)
      transpileOptionalToken(argument.separator, context)
    }
    transpileTokenWithText(typeArgumentlist.greaterThanToken, ">", context)
    inGenericTypeArgumentList = false
  }


  def transpileQualifiedName(name: NameSyntax.QualifiedNameSyntax, context: TranspilerContext) = {
    transpileName(name.left, context)
    name.right match {
      case _: SimpleNameSyntax.GenericNameSyntax =>
        transpileToken(name.dotToken, context)
        transpileSimpleName(name.right, context)
      case SimpleNameSyntax.IdentifierNameSyntax(identifier) =>
        if (isWildcardImport(identifier)) {
          // skip . and _ in `import bleh._`
          transpileTokenWithText(name.dotToken, "", context)
          transpileTokenWithText(identifier, "", context)
        } else {
          transpileToken(name.dotToken, context)
          transpileSimpleName(name.right, context)
        }
    }
  }

  def isWildcardImport(identifier: SyntaxToken): bool = {
    if (!inUsing) false
    else {
      val text = identifier.text
      text == "_" || text == "*"
    }
  }
}
