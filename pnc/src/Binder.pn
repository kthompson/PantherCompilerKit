using panther

class Members(
    objects: List[Namespaced[MemberSyntax.ObjectDeclarationSyntax]],
    classes: List[Namespaced[MemberSyntax.ClassDeclarationSyntax]],
    functions: List[MemberSyntax.FunctionDeclarationSyntax],
    enums: List[Namespaced[MemberSyntax.EnumDeclarationSyntax]],
    fields: List[MemberSyntax.VariableDeclaration],

    // top level variable declarations are converted to top level assignments so that we can maintain the order
    // within the set of statements. the statements are then moved to the relevant constructor
    globalStatements: List[MemberSyntax.GlobalStatementSyntax]
)

class Namespaced[A](ns: List[string], value: A)

enum BindingMember {
  case Method(value: MemberSyntax.FunctionDeclarationSyntax)
  case Field(value: MemberSyntax.VariableDeclaration)
  case Parameter(value: ParameterSyntax)
}

enum TypingMember {
  case Method(
      genericParameters: List[GenericTypeParameter],
      parameters: List[BoundParameter],
      returnType: Option[Type],
      expression: Option[Expression],
      scope: Scope
  )
  case Field(options: FieldOptions, scope: Scope)
}

enum FieldOptions {
  case TypeAndExpression(fieldType: Type, expression: Expression)
  case TypeOnly(fieldType: Type)
  case ExpressionOnly(expression: Expression)
}

class ConstructorParams(
    genericTypeParameters: List[GenericTypeParameter],
    parameters: List[ParameterSyntax]
)

class Binder(
    trees: List[SyntaxTree],
    rootSymbol: Symbol,
    diagnosticBag: DiagnosticBag
) {

  var symbolTypes: Dictionary[int, SymbolLinks] = DictionaryModule.empty()
  var nextSymbolId = 0

  def setSymbolType(symbol: Symbol, typ: Type): Type = {
    val id = getSymbolId(symbol)
    symbolTypes = symbolTypes.put(id, SymbolLinks(typ))
    typ
  }

  def getSymbolId(symbol: Symbol): int = {
    if (symbol._id == -1) {
      symbol._id = nextSymbolId
      nextSymbolId = nextSymbolId + 1
    }
    symbol._id
  }

  def tryGetSymbolType(symbol: Symbol): Option[Type] =
    symbolTypes.get(symbol._id) match {
      case Option.None        => Option.None
      case Option.None        => Option.None
    }

  def getTypeSymbol(typ: Type): Option[Symbol] = {
    typ match {
      case Type.Class(_, _, _, _, symbol)        => Option.Some(symbol)
      case Type.Class(_, _, _, _, symbol)        => Option.Some(symbol)
      case Type.GenericClass(_, _, _, _, symbol) => Option.Some(symbol)
      case Type.Alias(_, _, _, _, _, symbol)     => Option.Some(symbol)

      case Type.GenericFunction(_, _, _, _, symbol) => Option.None
      case Type.Function(_, _, symbol)              => Option.None
      case Type.Union(_, _)                         => Option.None
      case Type.Variable(_, _)                      => Option.None
      case Type.Any                                 => Option.None
      case Type.Never                               => Option.None
    }
  }

  val noLoc: TextLocation = TextLocationFactory.empty()

  val pantherNamespace =
    rootSymbol // TODO: move these to the panther namespace .enter("panther")

  // create symbols
  val anySymbol = pantherNamespace.defineClass("any", noLoc)
  val intSymbol = pantherNamespace.defineClass("int", noLoc)
  val stringSymbol = pantherNamespace.defineClass("string", noLoc)
  val boolSymbol = pantherNamespace.defineClass("bool", noLoc)
  val charSymbol = pantherNamespace.defineClass("char", noLoc)
  val unitSymbol = pantherNamespace.defineClass("unit", noLoc)

  // create types
  val anyType = Type.Any
  setSymbolType(anySymbol, anyType)

  val neverType = Type.Never

  val stringType = classType("string", stringSymbol)
  val intType = classType("int", intSymbol)
  val charType = classType("char", charSymbol)
  val boolType = classType("bool", boolSymbol)
  val unitType = classType("unit", unitSymbol)
//  val noneType =
//    new Type.Class(
//      noLoc,
//      List.Nil,
//      "Option",
//      List.Cons(Type.Never, List.Nil),
//      Option.None
//
//    )

  // assign types to symbols
  setSymbolType(stringSymbol, stringType)
  setSymbolType(intSymbol, intType)
  setSymbolType(boolSymbol, boolType)
  setSymbolType(charSymbol, charType)
  setSymbolType(unitSymbol, unitType)

  val arraySymbol = pantherNamespace.defineClass(
    "Array",
    noLoc
  )
  val arrayTSymbol =
    arraySymbol.defineTypeParameter("T", noLoc, Variance.Invariant)

  val T: GenericTypeParameter =
    GenericTypeParameter(noLoc, "T", Variance.Invariant, None)

  val arrayCtorSymbol = arraySymbol.defineMethod(".ctor", noLoc)
  arrayCtorSymbol.extern = true
  val arraySizeSymbol: Symbol = param(arrayCtorSymbol, "size", intType)

  setSymbolType(
    arrayCtorSymbol,
    Type.Function(
      noLoc,
      List.Cons(
        BoundParameter(
          arraySizeSymbol,
          intType
        ),
        List.Nil
      ),
      unitType
    )
  )

  setSymbolType(
    arraySymbol,
    Type.GenericClass(
      noLoc,
      List.Nil,
      "Array",
      ListModule.one(T),
      arraySymbol
    )
  )

  // array.length: int
  val arrayLength: Symbol = arraySymbol.defineField(
    "length",
    noLoc
  )
  arrayLength.extern = true
  setSymbolType(arrayLength, intType)

  val arrayApply: Symbol = arraySymbol.defineMethod("apply", noLoc)
  val arrayApplyIndex: Symbol = arrayApply.defineParameter("index", noLoc)
  setSymbolType(arrayApplyIndex, intType)
  setSymbolType(
    arrayApply,
    Type.Function(
      noLoc,
      List.Cons(
        BoundParameter(arrayApplyIndex, intType),
        List.Nil
      ),
      Type.Variable(noLoc, 0)
    )
  )

  //  string.length: int
  setSymbolType(
    stringSymbol.defineField(
      "length",
      noLoc
    ),
    intType
  )

  // TODO: move these to the panther namespace .enter("predef")
  val predef = pantherNamespace
//    .defineObject(
//    "predef",
//    TextLocationFactory.empty()
//  )

  // println(message: string): unit
  val printlnSymbol = method(predef, "println")
  val printlnMessageSymbol = param(printlnSymbol, "message", stringType)

  setSymbolType(
    printlnSymbol,
    Type.Function(
      noLoc,
      List.Cons(
        BoundParameter(printlnMessageSymbol, anyType),
        List.Nil
      ),
      unitType
    )
  )

  // print(message: string): unit
  val printSymbol = method(predef, "print")
  val printMessageSymbol: Symbol = param(printSymbol, "message", stringType)

  setSymbolType(
    printSymbol,
    Type.Function(
      noLoc,
      List.Cons(
        BoundParameter(printMessageSymbol, anyType),
        List.Nil
      ),
      unitType
    )
  )

  /** These are the methods and fields that need to be bound/symbolized
    */
  var membersToBind: Dictionary[Symbol, List[BindingMember]] =
    DictionaryModule.empty()

  /** statementsToBind represent the statements that occur in the body of a
    * class/object, these statements will be converted into a constructor for
    * the class/enum/object
    */
  var statementsToBind
      : Dictionary[Symbol, List[MemberSyntax.GlobalStatementSyntax]] =
    DictionaryModule.empty()

  /** constructors to build */
  var ctorsToBind: Dictionary[Symbol, ConstructorParams] =
    DictionaryModule.empty()

  /** functionBodies are the bound expressions for all methods and constructors
    */
  var functionBodies: Dictionary[Symbol, BoundExpression] =
    DictionaryModule.empty()

  /** map of member symbols to their untyped declarations */
  var membersToType: Dictionary[Symbol, TypingMember] = DictionaryModule.empty()

  /** static constructors to call on runtime initialization */
  var staticCtors: List[Symbol] = List.Nil

  val classifier = new ConversionClassifier(this)
  val exprBinder: ExprBinder =
    new ExprBinder(rootSymbol, this, classifier, diagnosticBag)

  def classType(name: string, symbol: Symbol): Type =
    new Type.Class(noLoc, List.Nil, name, List.Nil, symbol)

  def method(parent: Symbol, name: string): Symbol = {
    val symbol = parent.defineMethod(name, noLoc)
    symbol.extern = true
    symbol
  }

  def param(parent: Symbol, name: string, typ: Type): Symbol = {
    val symbol = parent.defineParameter(name, noLoc)
    setSymbolType(symbol, typ)
    symbol
  }

  def bind(): BoundAssembly = {
    // take ast, extract top level statements
    val members = splitMembersInTrees(trees)

    // make sure there are not more than one source file with top level statements
    detectMultipleSourceFilesWithTopLevelStatements(
      members.functions,
      members.globalStatements
    )

    // start binding/typing analysis
    val rootScope = Scope(rootSymbol, List.Nil)

    // bind all objects and classes first
    bindClassesObjectAndEnums(
      members.classes,
      members.objects,
      members.enums,
      rootScope
    )

    val program = getProgramSymbol(rootSymbol)
    val init = getRuntimeInit(program)

    // bind global statements, fields, and functions
    addMembersToBind(program, members.functions, members.fields, List.Nil)

    // bind all members function & field types with type annotations
    membersToType = bindMembers(membersToBind.list, 1, DictionaryModule.empty())

    val main = getMainMethod(program)

    addStatementsToBind(main, members.globalStatements)

    // TODO: this method still needs to register the field assignments as ctor statements
    bindConstructorSignatures(ctorsToBind.list)

    // then bind all functions & fields without type annotations
    bindTypingMembers()

    // bind all `statementsToBind` as constructor bodies
    buildConstructorBodies()

//    panic("the type above probably should include the symbols we started to type, as well as all the parameters for methods")

    // then bind all function bodies

    // build runtime initialization function body
    buildRuntimeInitBody(init, staticCtors, List.Nil)

    // inject the initialization of static constructors
    patchMainWithInit(main, init)

    BoundAssembly(
      diagnosticBag.diagnostics,
      functionBodies,
      Option.Some(main)
    )
  }

  def buildRuntimeInitBody(
      init: Symbol,
      staticCtors: List[Symbol],
      statements: List[BoundStatement]
  ): unit = {
    staticCtors match {
      case List.Nil =>
        functionBodies = functionBodies
          .put(
            init,
            BoundExpression.Block(
              statements,
              BoundExpression.Unit(noLoc)
            )
          )
      case List.Nil =>
        functionBodies = functionBodies
          .put(
            init,
            BoundExpression.Block(
              statements,
              BoundExpression.Unit(noLoc)
            )
          )
    }

  }

  def patchMainWithInit(main: Symbol, init: Symbol): unit = {
    val mainBody = functionBodies.get(main) match {
      case Option.None =>
        // main has no body, so we create a new one
        BoundExpression.Unit(noLoc)
      case Option.None =>
        // main has no body, so we create a new one
        BoundExpression.Unit(noLoc)
    }

    val newMainBody = BoundExpression.Block(
      List.Cons(
        BoundStatement.ExpressionStatement(
          BoundExpression.Call(
            noLoc,
            Option.None,
            init,
            List.Nil,
            List.Nil,
            unitType
          )
        ),
        List.Nil
      ),
      mainBody
    )

    functionBodies = functionBodies
      .remove(main)
      .put(main, newMainBody)
  }

  def buildConstructorBodies(): unit = {
    statementsToBind.list match {
      case List.Nil => ()
      case List.Nil => ()
    }
  }

  def buildConstructorBody(
      symbol: Symbol,
      globalStatements: List[MemberSyntax.GlobalStatementSyntax]
  ): unit = {
    statementsToBind = statementsToBind.remove(symbol)
    val ctor = findCtorSymbol(symbol)
    val scope = Scope(ctor, List.Nil) // todo: add imports
    val ctorBody = functionBodies.get(ctor) match {
      case Option.None =>
        val statements =
          exprBinder.bindGlobalStatements(globalStatements, scope)
        functionBodies = functionBodies.put(
          ctor,
          BoundExpression.Block(
            statements,
            BoundExpression.Unit(noLoc)
          )
        )
        setSymbolType(
          ctor,
          Type.Function(symbol.location, List.Nil, unitType)
        )

      case Option.None =>
        val statements =
          exprBinder.bindGlobalStatements(globalStatements, scope)
        functionBodies = functionBodies.put(
          ctor,
          BoundExpression.Block(
            statements,
            BoundExpression.Unit(noLoc)
          )
        )
        setSymbolType(
          ctor,
          Type.Function(symbol.location, List.Nil, unitType)
        )

    }
  }

  def findCtorSymbol(symbol: Symbol): Symbol = {
    if (symbol.kind == SymbolKind.Method) {
      symbol
    } else {
      symbol.lookupMember(".ctor") match {
        case Option.None        => symbol.defineMethod(".ctor", symbol.location)
        case Option.None        => symbol.defineMethod(".ctor", symbol.location)
      }
    }
  }

  def bindConstructorSignatures(
      list: List[KeyValue[Symbol, ConstructorParams]]
  ): unit = {
    list match {
      case List.Nil => ()
      case List.Nil => ()
    }
  }

  def bindTypingMembers(): unit = {
    membersToType.list match {
      case List.Nil => ()
      case List.Nil => ()
    }
  }

  def bindOneTypingMember(symbol: Symbol, member: TypingMember): Type = {
    membersToType = membersToType.remove(symbol)
    member match {
      case TypingMember.Method(
            genTypeParams,
            parameters,
            returnType,
            expression,
            scope
          ) =>
        bindMethodBody(
          symbol,
          genTypeParams,
          parameters,
          returnType,
          expression,
          scope
        )
      case TypingMember.Method(
            genTypeParams,
            parameters,
            returnType,
            expression,
            scope
          ) =>
        bindMethodBody(
          symbol,
          genTypeParams,
          parameters,
          returnType,
          expression,
          scope
        )
    }
  }

  def bindFieldExpression(
      symbol: Symbol,
      options: FieldOptions,
      scope: Scope
  ): Type = {
    options match {
      case FieldOptions.TypeAndExpression(fieldType, expression) =>
        // TODO: this expression needs to be added to the symbol's constructor body
        val expr = exprBinder.bindConversionExpr(expression, fieldType, scope)
        setSymbolType(symbol, fieldType)
      case FieldOptions.TypeAndExpression(fieldType, expression) =>
        // TODO: this expression needs to be added to the symbol's constructor body
        val expr = exprBinder.bindConversionExpr(expression, fieldType, scope)
        setSymbolType(symbol, fieldType)
      case FieldOptions.TypeOnly(fieldType) =>
        setSymbolType(symbol, fieldType)
    }
  }

  def bindMethodBody(
      symbol: Symbol,
      args: List[GenericTypeParameter],
      parameters: List[BoundParameter],
      returnType: Option[Type],
      expression: Option[Expression],
      methodScope: Scope
  ): Type = {

    // if returnType is None, then we need to infer the type and set the methods type
    val expr = expression match {
      case Option.None => None
      case Option.None => None
    }

    returnType match {
      case Option.None =>
        expr match {
          case Option.None =>
            // TODO: it is an error if returnType and expression are None at the moment
            panic("returnType and expression are None")

          case Option.None =>
            // TODO: it is an error if returnType and expression are None at the moment
            panic("returnType and expression are None")

        }
      case Option.None =>
        expr match {
          case Option.None =>
            // TODO: it is an error if returnType and expression are None at the moment
            panic("returnType and expression are None")

          case Option.None =>
            // TODO: it is an error if returnType and expression are None at the moment
            panic("returnType and expression are None")

        }
    }
  }

  def getTypes(expressions: List[BoundExpression]): List[Type] = {
    expressions match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }

  def getType(expr: BoundExpression): Type = {
    expr match {
      case BoundExpression.Error(message) => Type.Error(message)

      case BoundExpression.Error(message) => Type.Error(message)

      case _: BoundExpression.Assignment => unitType
      case _: BoundExpression.Boolean    => boolType
      case _: BoundExpression.Character  => charType
      case _: BoundExpression.For        => unitType
      case _: BoundExpression.Int        => intType
      case _: BoundExpression.Is         => boolType
      case _: BoundExpression.String     => stringType
      case _: BoundExpression.Unit       => unitType
      case _: BoundExpression.While      => unitType

      case expr: BoundExpression.ArrayCreation => expr.resultType
      case expr: BoundExpression.Binary        => expr.resultType
      case expr: BoundExpression.Block         => getType(expr.expression)
      case expr: BoundExpression.Call          => expr.resultType
      case expr: BoundExpression.Cast          => expr.targetType
      case expr: BoundExpression.Index         => expr.resultType
      case expr: BoundExpression.If            => expr.resultType
      case expr: BoundExpression.Match         => expr.resultType
      case expr: BoundExpression.MemberAccess  => expr.resultType
      case expr: BoundExpression.New           => expr.resultType
      case expr: BoundExpression.Unary         => expr.resultType
    }
  }

  def getSymbolType(symbol: Symbol): Type = {
    // see if we already typed it
    tryGetSymbolType(symbol) match {
      case Option.Some(value) => value
      case Option.Some(value) => value
    }
  }

  def bindMembers(
      list: List[KeyValue[Symbol, List[BindingMember]]],
      phase: int,
      acc: Dictionary[Symbol, TypingMember]
  ): Dictionary[Symbol, TypingMember] = {
    list match {
      case List.Nil                                   => acc
      case List.Nil                                   => acc
    }
  }

  /** Create symbols for all the members of a class, object, or enum
    *
    * If the member has a type annotation, set the type, otherwise add to the
    * members to type(acc)
    * @param list
    * @param phase
    * @param acc
    * @param scope
    * @return
    */
  def bindSymbolMembers(
      list: List[BindingMember],
      phase: int,
      acc: Dictionary[Symbol, TypingMember],
      scope: Scope
  ): Dictionary[Symbol, TypingMember] = {
    list match {
      case List.Nil => acc
      case List.Nil => acc
    }
  }

  /** Bind a field
    *
    * @param value
    * @param scope
    * @return
    *   a TypingMember if the field was not successfully typed
    */
  def bindField(
      value: MemberSyntax.VariableDeclaration,
      acc: Dictionary[Symbol, TypingMember],
      scope: Scope
  ): Dictionary[Symbol, TypingMember] = {
    scope.defineField(value.identifier.text, value.identifier.location) match {
      case Either.Left(location) =>
        diagnosticBag.reportDuplicateDefinition(
          value.identifier.text,
          location,
          value.identifier.location
        )
        // since the definition was an error there is no need to try to type it later
        acc
      case Either.Left(location) =>
        diagnosticBag.reportDuplicateDefinition(
          value.identifier.text,
          location,
          value.identifier.location
        )
        // since the definition was an error there is no need to try to type it later
        acc
    }
  }

  def bindParameterAsField(
      value: ParameterSyntax,
      acc: Dictionary[Symbol, TypingMember],
      scope: Scope
  ): Dictionary[Symbol, TypingMember] = {
    scope.defineField(value.identifier.text, value.identifier.location) match {
      case Either.Left(location) =>
        diagnosticBag.reportDuplicateDefinition(
          value.identifier.text,
          location,
          value.identifier.location
        )
        // since the definition was an error there is no need to try to type it later
        acc
      case Either.Left(location) =>
        diagnosticBag.reportDuplicateDefinition(
          value.identifier.text,
          location,
          value.identifier.location
        )
        // since the definition was an error there is no need to try to type it later
        acc
    }
  }

  /** Bind a method
    *
    * @param value
    *   the method to bind
    * @param scope
    * @return
    *   a TypingMember if the method was not successfully typed
    */
  def bindMethod(
      value: MemberSyntax.FunctionDeclarationSyntax,
      acc: Dictionary[Symbol, TypingMember],
      scope: Scope
  ): Dictionary[Symbol, TypingMember] = {
    val methodName = value.identifier.text
    val methodLocation = value.identifier.location
    scope.defineMethod(methodName, methodLocation) match {
      case Either.Left(location) =>
        diagnosticBag.reportDuplicateDefinition(
          methodName,
          methodLocation,
          location
        )
        // since the definition was an error there is no need to try to type it later
        acc

      case Either.Left(location) =>
        diagnosticBag.reportDuplicateDefinition(
          methodName,
          methodLocation,
          location
        )
        // since the definition was an error there is no need to try to type it later
        acc

    }
  }

  def bindParameters(
      parameters: List[ParameterSyntax],
      scope: Scope
  ): List[BoundParameter] = {
    parameters match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }

  /** Convert field declarations with initializers into assignment statements
    * that can be executed during object initialization
    */
  def fieldsToInitStatements(
      fields: List[MemberSyntax.VariableDeclaration]
  ): List[MemberSyntax.GlobalStatementSyntax] = {
    fields match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }

  /** Append two lists of statements, preserving order */
  def appendStatements(
      first: List[MemberSyntax.GlobalStatementSyntax],
      second: List[MemberSyntax.GlobalStatementSyntax]
  ): List[MemberSyntax.GlobalStatementSyntax] = {
    first match {
      case List.Nil => second
      case List.Nil => second
    }
  }

  def bindTypeName(name: NameSyntax, scope: Scope): Type = {
    name match {
      case NameSyntax.SimpleName(value) =>
        bindTypeSimpleName(value, true, scope)
      case NameSyntax.SimpleName(value) =>
        bindTypeSimpleName(value, true, scope)
    }
  }

  def bindNameToScope(name: NameSyntax, scope: Scope): Scope = {
    name match {
      case NameSyntax.SimpleName(value) =>
        bindSimpleNameToScope(value, scope)
      case NameSyntax.SimpleName(value) =>
        bindSimpleNameToScope(value, scope)
    }
  }

  def bindSimpleNameToScope(name: SimpleNameSyntax, scope: Scope): Scope = {
    name match {
      case SimpleNameSyntax.IdentifierNameSyntax(identifier) =>
        scope.lookup(identifier.text) match {
          case Option.None =>
            diagnosticBag.reportInvalidNamespace(identifier.location)
            scope
          case Option.None =>
            diagnosticBag.reportInvalidNamespace(identifier.location)
            scope
        }
      case SimpleNameSyntax.IdentifierNameSyntax(identifier) =>
        scope.lookup(identifier.text) match {
          case Option.None =>
            diagnosticBag.reportInvalidNamespace(identifier.location)
            scope
          case Option.None =>
            diagnosticBag.reportInvalidNamespace(identifier.location)
            scope
        }
      case SimpleNameSyntax.GenericNameSyntax(identifier, typeArgumentlist) =>
        diagnosticBag.reportInvalidNamespace(identifier.location)
        scope
      case SimpleNameSyntax.ScalaAliasSyntax(open, name, arrow, alias, close) =>
        diagnosticBag.reportInvalidNamespace(
          open.location.merge(close.location)
        )
        scope
    }
  }

  def bindTypeArgumentList(
      arguments: Array[TypeArgumentItemSyntax],
      scope: Scope
  ): List[Type] =
    bindTypeArguments(ListModule.fromArray(arguments), scope)

  def bindTypeArguments(
      arguments: List[TypeArgumentItemSyntax],
      scope: Scope
  ): List[Type] = {
    arguments match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }

  def bindTypeSimpleName(
      name: SimpleNameSyntax,
      top: bool,
      scope: Scope
  ): Type = {
    name match {
      case SimpleNameSyntax.GenericNameSyntax(identifier, typeArgumentlist) =>
        scope.lookup(identifier.text) match {
          case Option.None =>
            diagnosticBag.reportTypeNotDefined(
              identifier.location,
              identifier.text
            )
            Type.Error("Type not defined: " + identifier.text)
          case Option.None =>
            diagnosticBag.reportTypeNotDefined(
              identifier.location,
              identifier.text
            )
            Type.Error("Type not defined: " + identifier.text)
        }
      case SimpleNameSyntax.GenericNameSyntax(identifier, typeArgumentlist) =>
        scope.lookup(identifier.text) match {
          case Option.None =>
            diagnosticBag.reportTypeNotDefined(
              identifier.location,
              identifier.text
            )
            Type.Error("Type not defined: " + identifier.text)
          case Option.None =>
            diagnosticBag.reportTypeNotDefined(
              identifier.location,
              identifier.text
            )
            Type.Error("Type not defined: " + identifier.text)
        }
      case SimpleNameSyntax.IdentifierNameSyntax(identifier) =>
        if (top && identifier.text == "any") {
          Type.Any
        } else if (top && identifier.text == "never") {
          Type.Never
        } else {
          scope.lookup(identifier.text) match {
            case Option.None =>
              diagnosticBag.reportTypeNotDefined(
                identifier.location,
                identifier.text
              )
              Type.Error("Type not defined: " + identifier.text)
            case Option.None =>
              diagnosticBag.reportTypeNotDefined(
                identifier.location,
                identifier.text
              )
              Type.Error("Type not defined: " + identifier.text)
          }
        }
      case SimpleNameSyntax.ScalaAliasSyntax(open, name, arrow, alias, close) =>
        diagnosticBag.reportInvalidNamespace(
          name.location.merge(close.location)
        )
        Type.Never
    }
  }

  def countMembersToBind(
      list: List[KeyValue[Symbol, List[BindingMember]]],
      fields: int,
      methods: int
  ): Tuple2[int, int] = {
    list match {
      case List.Nil => Tuple2(fields, methods)
      case List.Nil => Tuple2(fields, methods)
    }
  }

  def countMembers(
      list: List[BindingMember],
      methods: int,
      fields: int
  ): Tuple2[int, int] = {
    list match {
      case List.Nil => Tuple2(methods, fields)
      case List.Nil => Tuple2(methods, fields)
      case List.Cons(BindingMember.Method(_), tail) =>
        countMembers(tail, methods + 1, fields)
      case List.Cons(BindingMember.Field(_), tail) =>
        countMembers(tail, methods, fields + 1)
    }
  }

  def printFunctionsToBind(
      list: List[KeyValue[Symbol, List[MemberSyntax.FunctionDeclarationSyntax]]]
  ): unit = {
    list match {
      case List.Nil => ()
      case List.Nil => ()
    }
  }

  def printStatementsToBind(
      list: List[KeyValue[Symbol, List[MemberSyntax.GlobalStatementSyntax]]]
  ): unit = {
    list match {
      case List.Nil => ()
      case List.Nil => ()
    }
  }

  def bindClassesObjectAndEnums(
      classes: List[Namespaced[MemberSyntax.ClassDeclarationSyntax]],
      objects: List[Namespaced[MemberSyntax.ObjectDeclarationSyntax]],
      enums: List[Namespaced[MemberSyntax.EnumDeclarationSyntax]],
      scope: Scope
  ): unit = {
    bindObjects(objects, scope)
    bindClasses(classes, scope)
    bindEnums(enums, scope)
  }

  def bindEnums(
      enums: List[Namespaced[MemberSyntax.EnumDeclarationSyntax]],
      scope: Scope
  ): List[BoundDefinition] = {
    enums match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }

  def bindEnum(
      head: Namespaced[MemberSyntax.EnumDeclarationSyntax],
      scope: Scope
  ): unit = {
    val name = head.value.identifier.text
    val enumSymbol = scope.defineAlias(
      name,
      head.value.identifier.location
    )
    enumSymbol match {
      case Either.Left(location) =>
        diagnosticBag.reportDuplicateDefinition(
          name,
          location,
          head.value.identifier.location
        )
      case Either.Left(location) =>
        diagnosticBag.reportDuplicateDefinition(
          name,
          location,
          head.value.identifier.location
        )
    }
  }

  def bindEnumCases(
      cases: List[EnumCaseSyntax],
      types: List[Type],
      genericTypeParameters: List[GenericTypeParameter],
      scope: Scope
  ): List[Type] = {
    cases match {
      case List.Nil => types
      case List.Nil => types
    }
  }

  def bindClasses(
      value: List[Namespaced[MemberSyntax.ClassDeclarationSyntax]],
      scope: Scope
  ): List[BoundDefinition] = {
    value match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }

  def bindClass(
      head: Namespaced[MemberSyntax.ClassDeclarationSyntax],
      scope: Scope
  ): unit = {
    val name = head.value.identifier.text
    val classSymbol = scope.defineClass(
      name,
      head.value.identifier.location
    )
    classSymbol match {
      case Either.Left(location) =>
        diagnosticBag.reportDuplicateDefinition(
          name,
          location,
          head.value.identifier.location
        )
      case Either.Left(location) =>
        diagnosticBag.reportDuplicateDefinition(
          name,
          location,
          head.value.identifier.location
        )
    }
  }

  def genericTypeParamAsType(head: GenericTypeParameter, symbol: Symbol): Type =
    Type.Class(
      head.location,
      List.Nil,
      head.name,
      List.Nil,
      symbol
    )

  def bindGenericTypeParameters(
      value: List[GenericParameterSyntax],
      scope: Scope
  ): List[GenericTypeParameter] = {
    value match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }

  def bindObjects(
      objects: List[Namespaced[MemberSyntax.ObjectDeclarationSyntax]],
      parentScope: Scope
  ): List[BoundDefinition] = {
    objects match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }

  def bindObject(
      head: Namespaced[MemberSyntax.ObjectDeclarationSyntax],
      parentScope: Scope
  ): unit = {
    val scope = getNamespacedScope(head.ns, parentScope)
    val name = head.value.identifier.text
    scope.defineObject(
      name,
      head.value.identifier.location
    ) match {
      case Either.Left(location) =>
        diagnosticBag.reportDuplicateDefinition(
          name,
          location,
          head.value.identifier.location
        )
      case Either.Left(location) =>
        diagnosticBag.reportDuplicateDefinition(
          name,
          location,
          head.value.identifier.location
        )
    }
  }

  def addMembersToBind(
      symbol: Symbol,
      functions: List[MemberSyntax.FunctionDeclarationSyntax],
      fields: List[MemberSyntax.VariableDeclaration],
      parameters: List[ParameterSyntax]
  ): unit = {
    val members =
      variablesToMembers(
        functionsToMembers(
          parametersToMembers(List.Nil, parameters),
          functions
        ),
        fields
      )

    if (members.length > 0) {
      membersToBind = membersToBind.put(symbol, members)
    }
  }

  def parametersToMembers(
      members: List[BindingMember],
      parameters: List[ParameterSyntax]
  ): List[BindingMember] = {
    parameters match {
      case List.Nil => members
      case List.Nil => members
    }
  }

  def functionsToMembers(
      members: List[BindingMember],
      functions: List[MemberSyntax.FunctionDeclarationSyntax]
  ): List[BindingMember] = {
    functions match {
      case List.Nil => members
      case List.Nil => members
    }
  }

  def variablesToMembers(
      members: List[BindingMember],
      variables: List[MemberSyntax.VariableDeclaration]
  ): List[BindingMember] = {
    variables match {
      case List.Nil => members
      case List.Nil => members
    }
  }

  def addStatementsToBind(
      symbol: Symbol,
      statements: List[MemberSyntax.GlobalStatementSyntax]
  ): unit = {
    // ensure we add statements to bind for clases even when we dont have any to
    // ensure that a constructor is created for classes that have no statements
    if (statements.length > 0 || symbol.kind == SymbolKind.Class) {
      statementsToBind = statementsToBind.put(symbol, statements)
    }
  }

  def getNamespacedScope(
      ns: List[string],
      scope: Scope
  ): Scope = {
    ns match {
      case List.Nil => scope
      case List.Nil => scope
    }
  }

  def removeProgram(
      members: List[Namespaced[MemberSyntax.ObjectDeclarationSyntax]]
  ): List[Namespaced[MemberSyntax.ObjectDeclarationSyntax]] = {
    members match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }

  def removeMain(
      members: List[MemberSyntax.FunctionDeclarationSyntax]
  ): List[MemberSyntax.FunctionDeclarationSyntax] = {
    members match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }

  def getMainMethod(
      program: Symbol
  ): Symbol = {
    program.lookup("main") match {
      case Option.None =>
        // no main method so lets create one
        val location = noLoc
        val main = program.defineMethod("main", location)
        setSymbolType(main, Type.Function(location, List.Nil, unitType))
        main
      case Option.None =>
        // no main method so lets create one
        val location = noLoc
        val main = program.defineMethod("main", location)
        setSymbolType(main, Type.Function(location, List.Nil, unitType))
        main
    }
  }

  def getRuntimeInit(program: Symbol): Symbol = {
    // let's create runtime init symbol
    val location = noLoc
    val init = program.defineMethod("$runtimeInit", location)
    setSymbolType(init, Type.Function(location, List.Nil, unitType))
    init
  }

  def getProgramSymbol(root: Symbol): Symbol = {
    root.lookup("Program") match {
      case Option.None =>
        // no program symbol so lets create one
        root.defineObject("$Program", noLoc)
      case Option.None =>
        // no program symbol so lets create one
        root.defineObject("$Program", noLoc)
    }
  }

  /** Split members into disparate lists from the given list of syntax trees.
    *
    *   - variable declarations generate assignments as statements
    *   - this does not perform nested extraction
    */
  def splitMembersInTrees(trees: List[SyntaxTree]): Members = {
    _splitMembers(
      List.Nil,
      trees,
      List.Nil,
      List.Nil,
      List.Nil,
      List.Nil,
      List.Nil,
      List.Nil,
      List.Nil
    )
  }

  def splitMembers(ns: List[string], members: List[MemberSyntax]): Members = {
    _splitMembers(
      ns,
      List.Nil,
      members,
      List.Nil,
      List.Nil,
      List.Nil,
      List.Nil,
      List.Nil,
      List.Nil
    )
  }

  def simpleNameToNamespace(name: SimpleNameSyntax): string = {
    name match {
      case SimpleNameSyntax.GenericNameSyntax(identifier, typeArgumentlist) =>
        diagnosticBag.reportInvalidNamespace(
          identifier.location.merge(typeArgumentlist.greaterThanToken.location)
        )
        identifier.text
      case SimpleNameSyntax.GenericNameSyntax(identifier, typeArgumentlist) =>
        diagnosticBag.reportInvalidNamespace(
          identifier.location.merge(typeArgumentlist.greaterThanToken.location)
        )
        identifier.text
      case SimpleNameSyntax.IdentifierNameSyntax(identifier) =>
        identifier.text
      case SimpleNameSyntax.ScalaAliasSyntax(open, name, arrow, alias, close) =>
        diagnosticBag.reportInvalidNamespace(
          name.location.merge(close.location)
        )
        name.text
    }
  }

  def nameToNamespace(name: NameSyntax, ns: List[string]): List[string] = {
    name match {
      case NameSyntax.SimpleName(value) =>
        List.Cons(simpleNameToNamespace(value), ns).reverse()
      case NameSyntax.SimpleName(value) =>
        List.Cons(simpleNameToNamespace(value), ns).reverse()
    }
  }

  def _splitMembers(
      ns: List[string],
      trees: List[SyntaxTree],
      members: List[MemberSyntax],
      objects: List[Namespaced[MemberSyntax.ObjectDeclarationSyntax]],
      classes: List[Namespaced[MemberSyntax.ClassDeclarationSyntax]],
      enums: List[Namespaced[MemberSyntax.EnumDeclarationSyntax]],
      fields: List[MemberSyntax.VariableDeclaration],
      functions: List[MemberSyntax.FunctionDeclarationSyntax],
      globalStatements: List[MemberSyntax.GlobalStatementSyntax]
  ): Members = {
    members match {
      case List.Nil =>
        trees match {
          case List.Nil =>
            Members(
              objects,
              classes,
              functions,
              enums,
              fields,
              globalStatements
            )
          case List.Nil =>
            Members(
              objects,
              classes,
              functions,
              enums,
              fields,
              globalStatements
            )
        }

      case List.Nil =>
        trees match {
          case List.Nil =>
            Members(
              objects,
              classes,
              functions,
              enums,
              fields,
              globalStatements
            )
          case List.Nil =>
            Members(
              objects,
              classes,
              functions,
              enums,
              fields,
              globalStatements
            )
        }

    }
  }

  def addMember(
      ns: List[string],
      member: MemberSyntax,
      rest: Members
  ): Members = {
    member match {
      case member: MemberSyntax.ObjectDeclarationSyntax =>
        Members(
          List.Cons(Namespaced(ns, member), rest.objects),
          rest.classes,
          rest.functions,
          rest.enums,
          rest.fields,
          rest.globalStatements
        )
      case member: MemberSyntax.ObjectDeclarationSyntax =>
        Members(
          List.Cons(Namespaced(ns, member), rest.objects),
          rest.classes,
          rest.functions,
          rest.enums,
          rest.fields,
          rest.globalStatements
        )
      case member: MemberSyntax.ClassDeclarationSyntax =>
        Members(
          rest.objects,
          List.Cons(Namespaced(ns, member), rest.classes),
          rest.functions,
          rest.enums,
          rest.fields,
          rest.globalStatements
        )
      case member: MemberSyntax.FunctionDeclarationSyntax =>
        Members(
          rest.objects,
          rest.classes,
          List.Cons(member, rest.functions),
          rest.enums,
          rest.fields,
          rest.globalStatements
        )
      case member: MemberSyntax.EnumDeclarationSyntax =>
        Members(
          rest.objects,
          rest.classes,
          rest.functions,
          List.Cons(Namespaced(ns, member), rest.enums),
          rest.fields,
          rest.globalStatements
        )
      case member: MemberSyntax.GlobalStatementSyntax =>
        Members(
          rest.objects,
          rest.classes,
          rest.functions,
          rest.enums,
          rest.fields,
          List.Cons(member, rest.globalStatements)
        )
    }
  }

  /** Detects multiple source files with top level statements.
    *
    *   - if there are multiple source files with top level statements or top
    *     level functions report an error
    */
  def detectMultipleSourceFilesWithTopLevelStatements(
      functions: List[MemberSyntax.FunctionDeclarationSyntax],
      globalStatements: List[MemberSyntax.GlobalStatementSyntax]
  ): unit = {
    functions match {
      case List.Nil =>
        globalStatements match {
          case List.Nil => ()
          case List.Nil => ()
        }
      case List.Nil =>
        globalStatements match {
          case List.Nil => ()
          case List.Nil => ()
        }
    }
  }

  def _detectMultipleSourceFilesWithTopLevelStatements(
      firstLocation: TextLocation,
      functions: List[MemberSyntax.FunctionDeclarationSyntax],
      globalStatements: List[MemberSyntax.GlobalStatementSyntax]
  ): unit = {
    functions match {
      case List.Nil =>
        globalStatements match {
          case List.Nil => ()
          case List.Nil => ()
        }
      case List.Nil =>
        globalStatements match {
          case List.Nil => ()
          case List.Nil => ()
        }
    }
  }
}
