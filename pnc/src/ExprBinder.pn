using BoundLeftHandSide.Index
using panther
//import Type.Reference

// object TypeSchemeKind {
//     val Polymorphic = 1
//     val Simple = 2
// }

// class TypeScheme(kind: int, polymorphic: Array[PolymorphicType], simple: Array[SimpleType])

// class PolymorphicType(body: SimpleType)

// object SimpleTypeKind {
//     val Variable = 1
//     val Concrete = 2
// }
// class SimpleType(kind: int, variable: Array[Variable], concrete: Array[ConcreteType]) {
//     def is_any(): bool = kind == SimpleTypeKind.Concrete && concrete[0].kind == ConcreteTypeKind.Any
//     def is_nothing(): bool = kind == SimpleTypeKind.Concrete && concrete[0].kind == ConcreteTypeKind.Nothing
// }

// object ConcreteTypeKind {
//     val Any = 1 // Top
//     val Nothing = 2 // Bottom
//     val Function = 3
//     val Record = 4
//     val Primitive = 5
//     val Array = 5
// }

// enum ConcreteType {
//   case Function(params: Array[SimpleType], returnType: SimpleType)
//   case Array(typ: Type)
//   case Record(fields: Array[RecordField])
//   case Primitive(name: string)
//   case Variable(lower: ConcreteType, upper: ConcreteType)
// )

// Any is Top (super type of all types)
// Nothing is Bottom (sub type of all types)

// https://github.com/LPTK/simpler-sub/blob/simpler-sub/shared/src/main/scala/simplesub/Typer.scala

// ∩ == intersection
// ∪ == union
//
// https://www.youtube.com/watch?v=d10q-b8jNKg
// x gets type variable A
// y gets type variable B

// union of branches gets type variable C

// constraint: A <= int
// constraint: B <= int
// constraint: A, B <= C

// f: A -> B -> C where A <= int, B <= int, A ∪ B <= C
// then (coalesce bounds)
// f: A ∩ int -> B ∩ int -> A ∪ B ∪ C
// then simplify variables
// f: A ∩ int -> A ∩ int -> A

// will be connected to a Declaration or an Expression

class TypePair(t1: Type, t2: Type)

class ExprBinder(
    rootSymbol: Symbol,
    binder: Binder,
    conversionClassifier: ConversionClassifier,
    diagnosticBag: DiagnosticBag
) {

  val operators = new BinaryOperators(binder)

  /**   1. Base rules:
    *      - Never is a subtype of all types.
    *      - All types are subtypes of Any.
    *      - A type is a subtype of itself.
    *        2. Function Subtyping:
    *   - Function types are covariant in the return type and contravariant in
    *     the parameter types:
    *     - (A1, A2) => R1 is a subtype of (B1, B2) => R2 if:
    *     - B1 is a subtype of A1 (contravariant in parameters),
    *     - B2 is a subtype of A2 (contravariant in parameters), and
    *     - R1 is a subtype of R2 (covariant in the return type).
    *
    *   3. Array Subtyping:
    *      - ArrayType(T1) is a subtype of ArrayType(T2) if T1 is a subtype of
    *        T2.
    *        4. Option Subtyping:
    *      - OptionType(T1) is a subtype of OptionType(T2) if T1 is a subtype of
    *        T2.
    *        5. Reference Types:
    *      - Reference(S1) is a subtype of Reference(S2) if they refer to the
    *        same symbol (assuming no polymorphism in this example).
    */

  def bindUnaryOperator(token: SyntaxToken): UnaryOperatorKind = {
    token.kind match {
      case SyntaxKind.BangToken  => UnaryOperatorKind.LogicalNegation
      case SyntaxKind.BangToken  => UnaryOperatorKind.LogicalNegation
      case SyntaxKind.PlusToken  => UnaryOperatorKind.Identity
      case SyntaxKind.DashToken  => UnaryOperatorKind.Negation
      case SyntaxKind.TildeToken => UnaryOperatorKind.BitwiseNegation
    }
  }

  def bindBinaryOperator(token: SyntaxToken): BinaryOperatorKind = {
    token.kind match {
      case SyntaxKind.AmpersandAmpersandToken => BinaryOperatorKind.LogicalAnd
      case SyntaxKind.AmpersandAmpersandToken => BinaryOperatorKind.LogicalAnd
      case SyntaxKind.AmpersandToken          => BinaryOperatorKind.BitwiseAnd
      case SyntaxKind.BangEqualsToken         => BinaryOperatorKind.NotEquals
      case SyntaxKind.CaretToken              => BinaryOperatorKind.BitwiseXor
      case SyntaxKind.DashToken               => BinaryOperatorKind.Minus
      case SyntaxKind.EqualsEqualsToken       => BinaryOperatorKind.Equals
      case SyntaxKind.GreaterThanEqualsToken =>
        BinaryOperatorKind.GreaterThanOrEqual
      case SyntaxKind.GreaterThanToken => BinaryOperatorKind.GreaterThan
      case SyntaxKind.GreaterThanGreaterThanToken =>
        BinaryOperatorKind.ShiftRight
      case SyntaxKind.LessThanEqualsToken => BinaryOperatorKind.LessThanOrEqual
      case SyntaxKind.LessThanToken       => BinaryOperatorKind.LessThan
      case SyntaxKind.LessThanLessThanToken => BinaryOperatorKind.ShiftLeft
      case SyntaxKind.PercentToken          => BinaryOperatorKind.Modulus
      case SyntaxKind.PipePipeToken         => BinaryOperatorKind.LogicalOr
      case SyntaxKind.PipeToken             => BinaryOperatorKind.BitwiseOr
      case SyntaxKind.PlusToken             => BinaryOperatorKind.Plus
      case SyntaxKind.SlashToken            => BinaryOperatorKind.Divide
      case SyntaxKind.StarToken             => BinaryOperatorKind.Multiply
    }
  }

  def bind(expr: Expression, scope: Scope): BoundExpression = {
    expr match {
      case node: Expression.ArrayCreationExpression =>
        bindArrayCreationExpression(node, scope)
      case node: Expression.ArrayCreationExpression =>
        bindArrayCreationExpression(node, scope)
      case node: Expression.AssignmentExpression =>
        bindAssignmentExpression(node, scope)
      case node: Expression.BinaryExpression =>
        bindBinaryExpression(node, scope)
      case node: Expression.BlockExpression => bindBlockExpression(node, scope)
      case node: Expression.CallExpression =>
        bindCallExpression(node, scope) match {
          case Result.Error(value)   => value
          case Result.Error(value)   => value
        }
      case node: Expression.CastExpression  => bindCast(node, scope)
      case node: Expression.ForExpression   => bindForExpression(node, scope)
      case node: Expression.GroupExpression => bindGroupExpression(node, scope)
      case node: Expression.IdentifierName =>
        bindIdentifierName(node, scope) match {
          case Result.Error(value)   => value
          case Result.Error(value)   => value
        }
      case node: Expression.If           => bindIf(node, scope)
      case node: Expression.IsExpression => bindIsExpression(node, scope)
      case node: Expression.LiteralExpression =>
        bindLiteralExpression(node, scope)
      case node: Expression.MemberAccessExpression =>
        bindMemberAccessExpression(node, scope) match {
          case Result.Error(value)   => value
          case Result.Error(value)   => value
        }
      case node: Expression.MatchExpression => bindMatchExpression(node, scope)
      case node: Expression.NewExpression =>
        bindNewExpression(node, scope) match {
          case Result.Error(value)   => value
          case Result.Error(value)   => value
        }
      case node: Expression.UnaryExpression => bindUnaryExpression(node, scope)
      case node: Expression.UnitExpression  => bindUnitExpression(node, scope)
    }
  }

  def bindLHS(
      expr: Expression,
      scope: Scope
  ): Result[BoundExpression.Error, BoundLeftHandSide] = {
    expr match {
      case node: Expression.IdentifierName =>
        bindIdentifierName(node, scope) match {
          case Result.Error(value) => Result.Error(value)
          case Result.Error(value) => Result.Error(value)
        }
      case node: Expression.IdentifierName =>
        bindIdentifierName(node, scope) match {
          case Result.Error(value) => Result.Error(value)
          case Result.Error(value) => Result.Error(value)
        }
      case node: Expression.MemberAccessExpression =>
        bindMemberAccessExpression(node, scope) match {
          case Result.Error(value) => Result.Error(value)
          case Result.Error(value) => Result.Error(value)
        }
      case node: Expression.CallExpression =>
        bindCallExpression(node, scope) match {
          case Result.Error(value)   => Result.Error(value)
          case Result.Error(value)   => Result.Error(value)
        }
      case node: Expression.NewExpression =>
        bindNewExpression(node, scope) match {
          case Result.Error(value)   => Result.Error(value)
          case Result.Error(value)   => Result.Error(value)
        }
    }
  }

  def bindConversionExpr(
      expr: Expression,
      toType: Type,
      scope: Scope
  ): BoundExpression = {
    val bound = bind(expr, scope)
    if (bound == BoundExpression.Error) {
      bound
    } else {
      bindConversion(bound, toType, false)
    }
  }

  def bindConversion(
      expr: BoundExpression,
      toType: Type,
      allowExplicit: bool
  ): BoundExpression = {
    expr match {
      case _: BoundExpression.Error => expr
      case _: BoundExpression.Error => expr
    }
  }

  def boundErrorExpression(text: string): BoundExpression = {
    println("\nbinding error: " + text + "\n")
    BoundExpression.Error("binding error: " + text)
  }

  def boundErrorStatement(text: string): BoundStatement = {
    panic("\nbinding error: " + text + "\n")
    BoundStatement.Error
  }

  def bindArrayCreationExpression(
      node: Expression.ArrayCreationExpression,
      scope: Scope
  ): BoundExpression = {
    // Extract the array element type from the name (e.g., Array[int])
    val arrayType = binder.bindTypeName(node.name, scope)

    // Extract the element type from the Array[T] type
    arrayType match {
      case Type.Class(_, _, "Array", List.Cons(elementType, List.Nil), _) =>
        // Bind the array size expression
        val sizeExpr = node.arrayRank match {
          case Option.Some(rankExpr) =>
            bindConversion(bind(rankExpr, scope), binder.intType, false)
          case Option.Some(rankExpr) =>
            bindConversion(bind(rankExpr, scope), binder.intType, false)
        }

        val location = AstUtils.locationOfExpression(node)

        elementType match {
          case Type.Error(message) => BoundExpression.Error(message)
          case Type.Error(message) => BoundExpression.Error(message)
        }
      case Type.Class(_, _, "Array", List.Cons(elementType, List.Nil), _) =>
        // Bind the array size expression
        val sizeExpr = node.arrayRank match {
          case Option.Some(rankExpr) =>
            bindConversion(bind(rankExpr, scope), binder.intType, false)
          case Option.Some(rankExpr) =>
            bindConversion(bind(rankExpr, scope), binder.intType, false)
        }

        val location = AstUtils.locationOfExpression(node)

        elementType match {
          case Type.Error(message) => BoundExpression.Error(message)
          case Type.Error(message) => BoundExpression.Error(message)
        }
    }

  }

  def bindAssignmentExpression(
      node: Expression.AssignmentExpression,
      scope: Scope
  ): BoundExpression = {
    val lhs = bindLHS(node.left, scope)
    val rhs = bind(node.right, scope)
    Tuple2(lhs, rhs) match {
      case Tuple2(Result.Error(error), _) =>
        error
      case Tuple2(Result.Error(error), _) =>
        error
      case Tuple2(_, BoundExpression.Error(_)) =>
        rhs
      case Tuple2(Result.Success(lhs), rhs) =>
        getLHSType(lhs) match {
          case Type.Error(message) => BoundExpression.Error(message)
          case Type.Error(message) => BoundExpression.Error(message)
        }

    }
  }

  def bindBinaryExpression(
      node: Expression.BinaryExpression,
      scope: Scope
  ): BoundExpression = {
    val left = bind(node.left, scope)
    val right = bind(node.right, scope)

    Tuple2(left, right) match {
      case Tuple2(BoundExpression.Error(_), _) =>
        left
      case Tuple2(BoundExpression.Error(_), _) =>
        left
      case Tuple2(_, BoundExpression.Error(_)) =>
        right
    }
  }

  def bindBlockExpression(
      node: Expression.BlockExpression,
      scope: Scope
  ): BoundExpression = {
    val block = scope.newBlock()
    val statements = bindStatements(node.block.statements, block)
    val expr = node.block.expression match {
      case Option.None =>
        BoundExpression.UnitExpression(TextLocationFactory.empty())
      case Option.None =>
        BoundExpression.UnitExpression(TextLocationFactory.empty())
    }

    if (expr == BoundExpression.Error) {
      expr
    } else {
      BoundExpression.Block(statements, expr)
    }
  }

  def isCast(node: Expression): bool = {
    node match {
      case Expression.IdentifierName(
            SimpleNameSyntax.IdentifierNameSyntax(value)
          ) =>
        val name = value.text
        name == "string" || name == "int" || name == "bool" || name == "char"
      case Expression.IdentifierName(
            SimpleNameSyntax.IdentifierNameSyntax(value)
          ) =>
        val name = value.text
        name == "string" || name == "int" || name == "bool" || name == "char"
    }
  }

  def typesWithError(list: List[Type]): bool = {
    list match {
      case List.Nil => false
      case List.Nil => false
    }
  }

  def bindCallExpression(
      node: Expression.CallExpression,
      scope: Scope
  ): Result[
    BoundExpression.Error,
    BoundLeftHandSide
  ] = {
    bindLHS(node.name, scope) match {
      case Result.Error(error) => Result.Error(error)

      case Result.Error(error) => Result.Error(error)

    }
  }

  def bindCall(
      function: BoundLeftHandSide,
      args: List[BoundExpression],
      scope: Scope
  ): Result[
    BoundExpression.Error,
    BoundLeftHandSide
  ] = {
    // cases:
    // 1. functions
    // 2. generic functions
    // 3. array indexing - array(0)
    // 3. class instantiation - Enum.Case(0)
    // 4. generic class instantiation
    // 5. string indexing

    val functionType = getLHSType(function)
    val argTypes = binder.getTypes(args)
    if (typesWithError(List.Cons(functionType, argTypes))) {
      Result.Error(
        BoundExpression.Error(
          "Cannot bind call expression because of type errors"
        )
      )
    } else
      functionType match {
        case func: Type.Function =>
          bindFunctionCall(function, func, args, scope) match {
            case Result.Error(value) => Result.Error(value)
            case Result.Error(value) => Result.Error(value)
          }
        case func: Type.Function =>
          bindFunctionCall(function, func, args, scope) match {
            case Result.Error(value) => Result.Error(value)
            case Result.Error(value) => Result.Error(value)
          }
        case Type.Class(_, ns, name, typeArgs, symbol) =>
          val location = AstUtils.locationOfBoundLeftHandSide(function)
          // Handle array indexing
          if (name == "Array") {
            args match {
              case List.Cons(indexArg, List.Nil) =>
                val boundIndex = bindConversion(indexArg, binder.intType, false)
                val elementType = typeArgs match {
                  case List.Cons(elemType, List.Nil) => elemType
                  case List.Cons(elemType, List.Nil) => elemType
                }
                val arrayExpr = function match {
                  case BoundLeftHandSide.Variable(loc, sym) =>
                    BoundExpression.Variable(
                      loc,
                      sym,
                      binder.tryGetSymbolType(sym)
                    )
                  case BoundLeftHandSide.Variable(loc, sym) =>
                    BoundExpression.Variable(
                      loc,
                      sym,
                      binder.tryGetSymbolType(sym)
                    )
                  case BoundLeftHandSide.MemberAccess(memberAccess) =>
                    memberAccess
                }
                val indexExpr = new BoundExpression.IndexExpression(
                  location,
                  arrayExpr,
                  boundIndex,
                  elementType
                )
                Result.Success(BoundLeftHandSide.Index(indexExpr))
              case List.Cons(indexArg, List.Nil) =>
                val boundIndex = bindConversion(indexArg, binder.intType, false)
                val elementType = typeArgs match {
                  case List.Cons(elemType, List.Nil) => elemType
                  case List.Cons(elemType, List.Nil) => elemType
                }
                val arrayExpr = function match {
                  case BoundLeftHandSide.Variable(loc, sym) =>
                    BoundExpression.Variable(
                      loc,
                      sym,
                      binder.tryGetSymbolType(sym)
                    )
                  case BoundLeftHandSide.Variable(loc, sym) =>
                    BoundExpression.Variable(
                      loc,
                      sym,
                      binder.tryGetSymbolType(sym)
                    )
                  case BoundLeftHandSide.MemberAccess(memberAccess) =>
                    memberAccess
                }
                val indexExpr = new BoundExpression.IndexExpression(
                  location,
                  arrayExpr,
                  boundIndex,
                  elementType
                )
                Result.Success(BoundLeftHandSide.Index(indexExpr))
            }
          } else {
            // Handle regular class constructors
            findConstructor(symbol) match {
              case Option.None =>
                diagnosticBag.reportNotCallable(location)
                Result.Error(
                  BoundExpression.Error(
                    "Cannot find constructor for class: " + name
                  )
                )
              case Option.None =>
                diagnosticBag.reportNotCallable(location)
                Result.Error(
                  BoundExpression.Error(
                    "Cannot find constructor for class: " + name
                  )
                )
            }
          }

      }
  }

  def bindFunctionCall(
      function: BoundLeftHandSide,
      functionType: Type.Function,
      args: List[BoundExpression],
      scope: Scope
  ): Result[BoundExpression.Error, BoundExpression.CallExpression] = {
    val location = AstUtils.locationOfBoundLeftHandSide(function)
    if (functionType.parameters.length != args.length) {
      diagnosticBag.reportArgumentCountMismatch(
        location,
        functionType.parameters.length,
        args.length
      )
      Result.Error(
        BoundExpression.Error(
          "Argument count mismatch: expected " + functionType.parameters.length +
            " but got " + args.length
        )
      )
    } else {
      val boundArgs = bindArguments(functionType.parameters, args, scope)

      function match {
        case BoundLeftHandSide.Index(expression) => ???
        case BoundLeftHandSide.Index(expression) => ???
        case BoundLeftHandSide.MemberAccess(access) =>
          val receiver = if (access.member.isStatic()) {
            Option.None
          } else {
            Option.Some(access.receiver)
          }
          Result.Success(
            BoundExpression.CallExpression(
              location,
              receiver,
              access.member,
              List.Nil, // TODO: generic arguments
              boundArgs,
              functionType.returnType
            )
          )
        case BoundLeftHandSide.Variable(location, symbol) =>
          Result.Success(
            BoundExpression.CallExpression(
              location,
              Option.None,
              symbol,
              List.Nil,
              boundArgs,
              functionType.returnType
            )
          )
      }
    }
  }

  def bindNewExpressionForSymbol(
      location: TextLocation,
      ctor: Symbol,
      ctorType: Type.Function,
      args: List[BoundExpression],
      scope: Scope
  ): Result[BoundExpression.Error, BoundLeftHandSide] = {
    if (ctorType.parameters.length != args.length) {
      diagnosticBag.reportArgumentCountMismatch(
        location,
        ctorType.parameters.length,
        args.length
      )
      Result.Error(
        BoundExpression.Error(
          "Argument count mismatch: expected " + ctorType.parameters.length +
            " but got " + args.length
        )
      )
    } else {
      val boundArgs = bindArguments(ctorType.parameters, args, scope)
      // Extract generic arguments from the return type (instantiation type)
      val genericArguments = ctorType.returnType match {
        case Type.Class(_, _, _, args, _) => args
        case Type.Class(_, _, _, args, _) => args
      }
      Result.Success(
        BoundLeftHandSide.New(
          BoundExpression.NewExpression(
            location,
            ctor,
            genericArguments,
            boundArgs,
            ctorType.returnType
          )
        )
      )
    }
  }

  def findConstructor(symbol: Symbol): Option[Symbol] =
    symbol.lookupMember(".ctor")

  def bindCast(
      cast: Expression.CastExpression,
      scope: Scope
  ): BoundExpression = {
    val expr = bind(cast.expression, scope)
    val typ = binder.bindTypeName(cast.typ, scope)

    expr match {
      case _: BoundExpression.Error => expr
      case _: BoundExpression.Error => expr
    }
  }

  def bindIsExpression(
      isExpr: Expression.IsExpression,
      scope: Scope
  ): BoundExpression = {
    val expr = bind(isExpr.expression, scope)
    val typ = binder.bindTypeName(isExpr.typ, scope)
    val location = AstUtils.locationOfExpression(isExpr)

    new BoundExpression.IsExpression(location, expr, typ)
  }

  def getParameterTypes(parameters: List[BoundParameter]): List[Type] = {
    parameters match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }

  def bindArguments(
      parameters: List[BoundParameter],
      arguments: List[BoundExpression],
      scope: Scope
  ): List[BoundExpression] = {
    parameters match {
      case List.Nil =>
        arguments match {
          case List.Nil => List.Nil
          case List.Nil => List.Nil
        }
      case List.Nil =>
        arguments match {
          case List.Nil => List.Nil
          case List.Nil => List.Nil
        }
    }
  }

  def fromExpressionList(
      list: List[ExpressionItemSyntax]
  ): List[Expression] =
    list match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }

  def bindExpressions(
      list: List[Expression],
      scope: Scope
  ): List[BoundExpression] =
    list match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }

  def bindForExpression(
      node: Expression.ForExpression,
      scope: Scope
  ): BoundExpression = {

    val blockScope = scope.newBlock()
    val lowerBound = bindConversionExpr(node.fromExpr, binder.intType, scope)
    val upperBound = bindConversionExpr(node.toExpr, binder.intType, scope)
    val identifier = node.identifier

    blockScope.defineLocal(identifier.text, identifier.location) match {
      case Either.Left(value) =>
        panic("symbol already defined even though that should not be possible")
      case Either.Left(value) =>
        panic("symbol already defined even though that should not be possible")
    }
  }

  def bindGroupExpression(
      node: Expression.GroupExpression,
      scope: Scope
  ): BoundExpression =
    bind(node.expression, scope)

  def bindIdentifierName(
      node: Expression.IdentifierName,
      scope: Scope
  ): Result[BoundExpression.Error, BoundExpression.Variable] = {
    node.value match {
      case SimpleNameSyntax.IdentifierNameSyntax(identifier) =>
        bindIdentifier(identifier, scope)
      case SimpleNameSyntax.IdentifierNameSyntax(identifier) =>
        bindIdentifier(identifier, scope)
      case generic: SimpleNameSyntax.GenericNameSyntax => ???
      case SimpleNameSyntax.ScalaAliasSyntax(open, name, arrow, alias, close) =>
        ???
    }
  }

  def bindIdentifier(
      identifier: SyntaxToken,
      scope: Scope
  ): Result[BoundExpression.Error, BoundExpression.Variable] = {
    scope.lookup(identifier.text) match {
      case Option.None =>
        diagnosticBag.reportSymbolNotFound(identifier.location, identifier.text)
        Result.Error(
          BoundExpression.Error(
            "Symbol not found: " + identifier.text + " at " + identifier.location
          )
        )
      case Option.None =>
        diagnosticBag.reportSymbolNotFound(identifier.location, identifier.text)
        Result.Error(
          BoundExpression.Error(
            "Symbol not found: " + identifier.text + " at " + identifier.location
          )
        )
    }
  }

  def bindIf(node: Expression.If, scope: Scope): BoundExpression = {
    val cond = bindConversionExpr(node.condition, binder.boolType, scope)
    val thenExpr = bind(node.thenExpr, scope)
    Tuple2(cond, thenExpr) match {
      case Tuple2(BoundExpression.Error(_), _) =>
        cond
      case Tuple2(BoundExpression.Error(_), _) =>
        cond
      case Tuple2(_, BoundExpression.Error(_)) =>
        thenExpr
    }
  }

  def bindLiteralExpression(
      node: Expression.LiteralExpression,
      scope: Scope
  ): BoundExpression = {
    node.value match {
      case SyntaxTokenValue.Number(value) =>
        BoundExpression.Int(node.token.location, value)
      case SyntaxTokenValue.Number(value) =>
        BoundExpression.Int(node.token.location, value)
      case SyntaxTokenValue.Boolean(value) =>
        BoundExpression.Boolean(node.token.location, value)
      case SyntaxTokenValue.String(value) =>
        BoundExpression.String(node.token.location, value)
      case SyntaxTokenValue.Character(value) =>
        BoundExpression.Character(node.token.location, value)
    }
  }

  def getLHSType(lhs: BoundLeftHandSide): Type = {
    lhs match {
      case BoundLeftHandSide.ArrayCreation(expression) =>
        binder.getType(expression)
      case BoundLeftHandSide.ArrayCreation(expression) =>
        binder.getType(expression)
      case BoundLeftHandSide.Call(expression) =>
        binder.getType(expression)
      case BoundLeftHandSide.Index(expression) =>
        binder.getType(expression)
      case BoundLeftHandSide.MemberAccess(expression) =>
        binder.getType(expression)
      case BoundLeftHandSide.New(expression) =>
        binder.getType(expression)

    }
  }

  def convertLHSToExpression(lhs: BoundLeftHandSide): BoundExpression = {
    lhs match {
      case BoundLeftHandSide.ArrayCreation(expression) =>
        expression
      case BoundLeftHandSide.ArrayCreation(expression) =>
        expression
      case BoundLeftHandSide.Call(expression) =>
        expression
      case BoundLeftHandSide.MemberAccess(expression) =>
        expression
      case BoundLeftHandSide.Index(expression) =>
        expression
      case BoundLeftHandSide.New(expression) =>
        expression
    }
  }

  def bindMemberAccessExpression(
      node: Expression.MemberAccessExpression,
      scope: Scope
  ): Result[BoundExpression.Error, BoundExpression.MemberAccess] = {
    // For member access, the left side doesn't need to be a left-hand side
    // It just needs to be a valid expression that produces a value
    val leftExpr = bindLHS(node.left, scope)
    leftExpr match {
      case Result.Error(error) =>
        Result.Error(error)
      case Result.Error(error) =>
        Result.Error(error)
    }
  }

  def getListElement(list: List[Type], index: int): Option[Type] = {
    list match {
      case List.Nil => Option.None
      case List.Nil => Option.None
    }
  }

  def substituteParameterTypes(
      params: List[BoundParameter],
      typeArgs: List[Type]
  ): List[BoundParameter] = {
    params match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }

  def substituteTypeVariable(typ: Type, typeArgs: List[Type]): Type = {
    typ match {
      case Type.Variable(loc, index) =>
        getListElement(typeArgs, index) match {
          case Option.Some(substituted) => substituted
          case Option.Some(substituted) => substituted
        }
      case Type.Variable(loc, index) =>
        getListElement(typeArgs, index) match {
          case Option.Some(substituted) => substituted
          case Option.Some(substituted) => substituted
        }
      case Type.Function(loc, params, returnType) =>
        Type.Function(
          loc,
          substituteParameterTypes(params, typeArgs),
          substituteTypeVariable(returnType, typeArgs)
        )
    }
  }

  def bindMemberForSymbolAndType(
      leftType: Type,
      right: SyntaxToken
  ): Either[string, Tuple2[Symbol, Type]] = {
    binder.getTypeSymbol(leftType) match {
      case Option.None =>
        diagnosticBag.reportSymbolNotFoundForType(
          right.location,
          leftType,
          right.text
        )
        Either.Left(
          "Symbol not found for type: " + leftType
            .toString() + " for member: " + right.text
        )
      case Option.None =>
        diagnosticBag.reportSymbolNotFoundForType(
          right.location,
          leftType,
          right.text
        )
        Either.Left(
          "Symbol not found for type: " + leftType
            .toString() + " for member: " + right.text
        )
    }
  }

  def bindPattern(
      pattern: PatternSyntax,
      scope: Scope
  ): Result[BoundExpression.Error, BoundPattern] = {
    pattern match {
      case PatternSyntax.Literal(token) =>
        token.value match {
          case SyntaxTokenValue.Number(value) =>
            Result.Success(
              BoundPattern.Literal(
                BoundLiteral.Int(token.location, value)
              )
            )
          case SyntaxTokenValue.Number(value) =>
            Result.Success(
              BoundPattern.Literal(
                BoundLiteral.Int(token.location, value)
              )
            )
          case SyntaxTokenValue.String(value) =>
            Result.Success(
              BoundPattern.Literal(
                BoundLiteral.String(token.location, value)
              )
            )
          case SyntaxTokenValue.Boolean(value) =>
            Result.Success(
              BoundPattern.Literal(
                BoundLiteral.Bool(token.location, value)
              )
            )
          case SyntaxTokenValue.Character(value) =>
            Result.Success(
              BoundPattern.Literal(
                BoundLiteral.Char(token.location, value)
              )
            )
        }
      case PatternSyntax.Literal(token) =>
        token.value match {
          case SyntaxTokenValue.Number(value) =>
            Result.Success(
              BoundPattern.Literal(
                BoundLiteral.Int(token.location, value)
              )
            )
          case SyntaxTokenValue.Number(value) =>
            Result.Success(
              BoundPattern.Literal(
                BoundLiteral.Int(token.location, value)
              )
            )
          case SyntaxTokenValue.String(value) =>
            Result.Success(
              BoundPattern.Literal(
                BoundLiteral.String(token.location, value)
              )
            )
          case SyntaxTokenValue.Boolean(value) =>
            Result.Success(
              BoundPattern.Literal(
                BoundLiteral.Bool(token.location, value)
              )
            )
          case SyntaxTokenValue.Character(value) =>
            Result.Success(
              BoundPattern.Literal(
                BoundLiteral.Char(token.location, value)
              )
            )
        }
      case PatternSyntax.Discard(_) =>
        Result.Success(BoundPattern.Discard)
      case PatternSyntax.Identifier(identifier, typeAnnotation) =>
        // Create a new local variable for the pattern binding
        scope.defineLocal(identifier.text, identifier.location) match {
          case Either.Left(originalLocation) =>
            diagnosticBag.reportDuplicateDefinition(
              identifier.text,
              originalLocation,
              identifier.location
            )
            Result.Error(
              BoundExpression.Error(
                "Duplicate pattern variable: " + identifier.text
              )
            )
          case Either.Left(originalLocation) =>
            diagnosticBag.reportDuplicateDefinition(
              identifier.text,
              originalLocation,
              identifier.location
            )
            Result.Error(
              BoundExpression.Error(
                "Duplicate pattern variable: " + identifier.text
              )
            )
//            // Set the symbol type from the type annotation
//            val boundType = binder.bindTypeName(typeAnnotation.typ, scope)
//            binder.setSymbolType(symbol, boundType)
//            Result.Success(BoundPattern.Variable(symbol))
        }
      case PatternSyntax.Type(typ) =>
        // For type patterns, we create a wildcard pattern
        // Type checking will be handled elsewhere
        Result.Success(BoundPattern.Discard)
    }
  }

  def bindMatchCase(
      matchCase: MatchCaseSyntax,
      scope: Scope
  ): Result[BoundExpression.Error, BoundMatchCase] = {
    // Create a new scope for this case to allow pattern variables
    val caseScope = scope.newBlock()

    bindPattern(matchCase.pattern, caseScope) match {
      case Result.Error(error)          => Result.Error(error)
      case Result.Error(error)          => Result.Error(error)
    }
  }

  def bindMatchCases(
      head: MatchCaseSyntax,
      tail: List[MatchCaseSyntax],
      scope: Scope
  ): Result[BoundExpression.Error, NonEmptyList[BoundMatchCase]] = {
    bindMatchCase(head, scope) match {
      case Result.Error(expr) =>
        Result.Error(expr)
      case Result.Error(expr) =>
        Result.Error(expr)
    }
  }

  def calculateMatchResultType(typ: Type, tail: List[BoundMatchCase]): Type = {
    tail match {
      case List.Nil              => typ
      case List.Nil              => typ
    }
  }

  def bindMatchExpression(
      node: Expression.MatchExpression,
      scope: Scope
  ): BoundExpression = {
    // Bind the expression being matched against
    val matchedExpr = bind(node.expression, scope)

    matchedExpr match {
      case error: BoundExpression.Error => error
      case error: BoundExpression.Error => error
    }
  }

  def bindNewExpression(
      node: Expression.NewExpression,
      scope: Scope
  ): Result[BoundExpression.Error, BoundLeftHandSide] = {
    val instantiationType = binder.bindTypeName(node.name, scope)
    instantiationType match {
      case Type.Error(message) => Result.Error(BoundExpression.Error(message))
      case Type.Error(message) => Result.Error(BoundExpression.Error(message))
      case Type.Class(_, ns, name, args, symbol) =>
        // Special handling for Array construction - convert to ArrayCreation
        if (name == "Array") {
          val elementType = args match {
            case List.Cons(elemType, List.Nil) => elemType
            case List.Cons(elemType, List.Nil) => elemType
          }
          val argsList = bindExpressions(
            fromExpressionList(node.arguments.expressions),
            scope
          )
          argsList match {
            case List.Cons(sizeArg, List.Nil) =>
              val boundSize = bindConversion(sizeArg, binder.intType, false)
              val location = AstUtils.locationOfExpression(node)
              val arrayCreation = new BoundExpression.ArrayCreation(
                location,
                elementType,
                boundSize,
                instantiationType // This is the Array[T] type
              )

              Result.Success(BoundLeftHandSide.ArrayCreation(arrayCreation))
            case List.Cons(sizeArg, List.Nil) =>
              val boundSize = bindConversion(sizeArg, binder.intType, false)
              val location = AstUtils.locationOfExpression(node)
              val arrayCreation = new BoundExpression.ArrayCreation(
                location,
                elementType,
                boundSize,
                instantiationType // This is the Array[T] type
              )

              Result.Success(BoundLeftHandSide.ArrayCreation(arrayCreation))
          }
        } else {
          findConstructor(symbol) match {
            case Option.None =>
              diagnosticBag.reportSymbolNotFound(
                AstUtils.locationOfName(node.name),
                name
              )
              Result.Error(
                BoundExpression.Error(
                  "Cannot find constructor for class: " + name
                )
              )
            case Option.None =>
              diagnosticBag.reportSymbolNotFound(
                AstUtils.locationOfName(node.name),
                name
              )
              Result.Error(
                BoundExpression.Error(
                  "Cannot find constructor for class: " + name
                )
              )
          }
        }
    }
  }

  def bindUnaryExpression(
      node: Expression.UnaryExpression,
      scope: Scope
  ): BoundExpression = {
    val op = bindUnaryOperator(node.operator)
    bind(node.expression, scope) match {
      case error: BoundExpression.Error => error
      case error: BoundExpression.Error => error
    }

  }

  def bindUnitExpression(
      node: Expression.UnitExpression,
      scope: Scope
  ): BoundExpression =
    BoundExpression.UnitExpression(
      node.openParen.location.merge(node.closeParen.location)
    )

  def bindWhileExpression(
      node: Expression.WhileExpression,
      scope: Scope
  ): BoundExpression = {
    val cond = bind(node.condition, scope)
    val body = bind(node.body, scope)
    new BoundExpression.WhileExpression(node.whileKeyword.location, cond, body)
  }

  def bindStatement(
      statement: StatementSyntax,
      scope: Scope
  ): BoundStatement = {
    statement match {
      case stmt: StatementSyntax.VariableDeclarationStatement =>
        bindVariableDeclarationStatement(stmt, scope)
      case stmt: StatementSyntax.VariableDeclarationStatement =>
        bindVariableDeclarationStatement(stmt, scope)
      case stmt: StatementSyntax.BreakStatement =>
        bindBreakStatement(stmt, scope)
      case stmt: StatementSyntax.ContinueStatement =>
        bindContinueStatement(stmt, scope)
    }
  }

  def bindVariableDeclarationStatement(
      statement: StatementSyntax.VariableDeclarationStatement,
      scope: Scope
  ): BoundStatement = {
    val identifier = statement.identifier
    val name = identifier.text
    val location = identifier.location
    scope.defineLocal(name, location) match {
      case Either.Left(originalLocation) =>
        // symbol is already defined in this scope
        diagnosticBag.reportDuplicateDefinition(
          name,
          originalLocation,
          location
        )
        BoundStatement.Error
      case Either.Left(originalLocation) =>
        // symbol is already defined in this scope
        diagnosticBag.reportDuplicateDefinition(
          name,
          originalLocation,
          location
        )
        BoundStatement.Error
    }
  }
  def bindBreakStatement(
      statement: StatementSyntax.BreakStatement,
      scope: Scope
  ): BoundStatement = {
    boundErrorStatement("bindBreakStatement")
  }
  def bindContinueStatement(
      statement: StatementSyntax.ContinueStatement,
      scope: Scope
  ): BoundStatement = {
    boundErrorStatement("bindContinueStatement")
  }
  def bindExpressionStatement(
      statement: StatementSyntax.ExpressionStatement,
      scope: Scope
  ): BoundStatement = {
    val expr = bind(statement.expression, scope)
    BoundStatement.ExpressionStatement(expr)
  }

  def bindGlobalStatements(
      statements: List[MemberSyntax.GlobalStatementSyntax],
      scope: Scope
  ): List[BoundStatement] = {
    statements match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }

  def bindStatements(
      statements: List[StatementSyntax],
      scope: Scope
  ): List[BoundStatement] = {
    statements match {
      case List.Nil => List.Nil
      case List.Nil => List.Nil
    }
  }
}
