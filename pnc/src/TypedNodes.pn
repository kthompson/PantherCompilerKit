using scala.Array as SArray
using scala.Option as SOption

enum Type {
  case Function(parameters: SArray<TypedParameter>, returnType: Type)
  case Array(inner: Type)
  case Reference(symbol: Symbol, baseType: SOption<Type>)
  case Option(inner: Type)
  case int
  case Bool
  case Class(name: ClassName)
  case Any
  case Never
  case unit

  case Error
}

enum TypedUnaryOperator {
  case Negate
  case Not
}

enum TypedBinaryOperator {
  case Add
  case And
  case Divide
  case Equal
  case Greater
  case GreaterOrEqual
  case Less
  case LessOrEqual
  case Multiply
  case NotEqual
  case Or
  case Subtract
}

class VariableName(name: string)

class ClassName(name: string)

class FieldName(name: string)

class MethodName(name: string)

class FunctionName(name: string)

class TypeBinding(name: VariableName, typ: Type)

enum TypeEnvironment {
  case Empty
  case Cons(binding: TypeBinding, tail: TypeEnvironment)
}

object Environment {
  def getVarType(variable: VariableName, env: TypeEnvironment): SOption<Type> = {
    env match {
      case TypeEnvironment.Empty => None
      case TypeEnvironment.Cons(binding, tail) =>
        if (binding.name == variable) {
          Some(binding.typ)
        } else {
          getVarType(variable, tail)
        }
    }
  }
}

enum TypedExpression {
  case ArrayCreationExpression(typ: Type, expression: Expression.ArrayCreationExpression)
  case AssignmentExpression(typ: Type, expression: Expression.AssignmentExpression)
  case BinaryExpression(typ: Type, expression: Expression.BinaryExpression)
  case BlockExpression(typ: Type, expression: Expression.BlockExpression)
  case CallExpression(typ: Type, expression: Expression.CallExpression)
  case ForExpression(typ: Type, expression: Expression.ForExpression)
  case GroupExpression(typ: Type, expression: Expression.GroupExpression)
  case IdentifierName(typ: Type, expression: Expression.IdentifierName)
  case IfExpression(typ: Type, expression: Expression.IfExpression)
  case IndexExpression(typ: Type, expression: Expression.IndexExpression)
  case LiteralExpression(typ: Type, expression: Expression.LiteralExpression)
  case MemberAccessExpression(typ: Type, expression: Expression.MemberAccessExpression)
  case MatchExpression(typ: Type, expression: Expression.MatchExpression)
  case NewExpression(typ: Type, expression: Expression.NewExpression)
  case UnaryExpression(typ: Type, expression: Expression.UnaryExpression)
  case UnitExpression(typ: Type, expression: Expression.UnitExpression)
  case WhileExpression(typ: Type, expression: Expression.WhileExpression)
}

class TypedParameter(name: string, typ: Type)

class TypedField(name: FieldName, typ: Type)

class TypedMethod(name: MethodName, returnType: Type, args: Array<TypedParameter>)


enum TypedDefinition {
  case TypedClass(namespace: string, name: string, fields: Array<TypedField>, members: Array<TypedMethod>)
  case TypedEnum(namespace: string, name: string, members: Array<string>)
}

class TypedAssembly(classes: Array<TypedDefinition>)

