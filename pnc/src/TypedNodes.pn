enum Type {
  case Function(parameters: Array<TypedParameter>, returnType: Type)
  case ArrayType(inner: Type)
  case Reference(symbol: Symbol, baseType: Option<Type>)
  case OptionType(inner: Type)
  case Class(name: ClassName)
  case int
  case Bool
  case Any
  case Never
  case unit

  case Error
}

enum TypedUnaryOperator {
  case Negate
  case Not
}

enum TypedBinaryOperator {
  case Add
  case And
  case Divide
  case Equal
  case Greater
  case GreaterOrEqual
  case Less
  case LessOrEqual
  case Multiply
  case NotEqual
  case Or
  case Subtract
}

class VariableName(name: string)

class ClassName(name: string)

class MemberName(name: string)

class NamespaceName(name: string)

class FunctionName(name: string)

class TypeBinding(name: VariableName, typ: Type)

enum TypeEnvironment {
  case Empty
  case Cons(binding: TypeBinding, tail: TypeEnvironment)
}

object Environment {
  def getVarType(variable: VariableName, env: TypeEnvironment): Option<Type> = {
    env match {
      case TypeEnvironment.Empty => None
      case TypeEnvironment.Cons(binding, tail) =>
        if (binding.name == variable) {
          Some(binding.typ)
        } else {
          getVarType(variable, tail)
        }
    }
  }
}

enum TypedExpression {
  case ArrayCreationExpression(typ: Type, expression: Expression.ArrayCreationExpression)
  case AssignmentExpression(typ: Type, expression: Expression.AssignmentExpression)
  case BinaryExpression(typ: Type, expression: Expression.BinaryExpression)
  case BlockExpression(typ: Type, expression: Expression.BlockExpression)
  case CallExpression(typ: Type, expression: Expression.CallExpression)
  case ForExpression(typ: Type, expression: Expression.ForExpression)
  case GroupExpression(typ: Type, expression: Expression.GroupExpression)
//  case IdentifierName(typ: Type, expression: Expression.IdentifierName)
  case IfExpression(typ: Type, expression: Expression.If)
  case IndexExpression(typ: Type, expression: Expression.IndexExpression)
  case LiteralExpression(typ: Type, expression: Expression.LiteralExpression)
//  case MemberAccessExpression(typ: Type, expression: Expression.MemberAccessExpression)
  case MatchExpression(typ: Type, expression: Expression.MatchExpression)
  case NewExpression(typ: Type, expression: Expression.NewExpression)
  case UnaryExpression(typ: Type, expression: Expression.UnaryExpression)
  case UnitExpression(typ: Type, expression: Expression.UnitExpression)
  case WhileExpression(typ: Type, expression: Expression.WhileExpression)
}

class TypedParameter(name: string, typ: Type)

class TypedField(name: MemberName, typ: Type)

class TypedMethod(name: MemberName, returnType: Type, args: Array<TypedParameter>)

enum TypedDefinition {
  case TypedObject(namespace: NamespaceName, name: ClassName, fields: Array<TypedField>, members: Array<TypedMethod>)
  case TypedClass(namespace: NamespaceName, name: ClassName, fields: Array<TypedField>, members: Array<TypedMethod>)
  case TypedEnum(namespace: NamespaceName, name: ClassName, members: Array<string>)
}

enum TypeDefinitions {
  case Empty
  case Cons(definition: TypedDefinition, tail: TypeDefinitions)
}

class TypedAssembly(definitions: Array<TypedDefinition>)

