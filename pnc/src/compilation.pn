using panther

object MakeCompilation {
  def create(trees: Array<SyntaxTree>): Compilation = {
    val diagnosticBag = new DiagnosticBag()
    val root = new Symbol(SymbolKind.Root, SymbolFlags.None, "", TextLocationFactory.empty(), None)

    val binder = new Binder(root, diagnosticBag)
    val boundTree = binder.bind(trees)


    // all the type inference data is in the checker so we cant
    // expose it to the compilation here
    //         val checker = new Checker(root)
    //         checker.initBuiltins()

    new Compilation(trees, root, /* checker, */ boundTree.diagnostics)
  }
}

class Compilation(syntaxTrees: Array<SyntaxTree>, root: Symbol, /*checker: Checker,*/ diagnostics: Array<Diagnostic>) {
  def print_symbols(): unit = SymbolTreePrinter.print_symbol(root)

  def emit(output: string): unit = {
    val emitter = new Emitter(syntaxTrees, root, /* checker, */ output)
    //        emitter.emit()
  }

  def transpile(outputPath: string): unit = {
    val transpiler = new Transpiler(syntaxTrees, root, outputPath)
    transpiler.transpile()
  }
}