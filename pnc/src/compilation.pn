using panther

object MakeCompilation {
  def create(trees: Array<SyntaxTree>): Compilation = {
    val diagnosticBag = new DiagnosticBag()
    for (i <- 0 to (trees.length - 1)) {
      diagnosticBag.addDiagnostics(trees(i).diagnostics)
    }
    val root = new Symbol(SymbolKind.Root, SymbolFlags.None, "", TextLocationFactory.empty(), None)
    val binder = new Binder(diagnosticBag, root)

    // creation of the checker will initialize all of the builtin symbols and their types into the
    // root symbol table
    val checker = new Checker(diagnosticBag, root)

    val boundTree = binder.bind(trees)

//    checker.check(boundTree.functions, boundTree.fields)

    new Compilation(trees, root, checker, diagnosticBag.diagnostics)
  }
}

class Compilation(syntaxTrees: Array<SyntaxTree>, root: Symbol, checker: Checker, diagnostics: Diagnostics) {
  def printSymbols(): unit = SymbolTreePrinter(checker).printSymbol(root)

  def emit(output: string): unit = {
    val emitter = new Emitter(syntaxTrees, root, /* checker, */ output)
    //        emitter.emit()
  }

  def transpile(outputPath: string): unit = {
    val transpiler = new Transpiler(syntaxTrees, root, outputPath)
    transpiler.transpile()
  }
}