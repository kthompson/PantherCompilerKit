using panther

object Program {
  def main(args: Array<string>): unit = {
    print("pncs")
    for (i <- 0 to (args.length - 1)) {
      print(" " + args(i))
    }
    println()

    if (args.length < 2) {
      printHelp()
    } else if (args(0) == "-t") {
      run(true, args)
    } else {
      run(false, args)
    }
  }

  def hasDiagnostics(trees: Array<SyntaxTree>): bool = {
    var diags = false
    for (i <- 0 to (trees.length - 1)) {
      trees(i).diagnostics match {
        case Diagnostics.Empty => ()
        case _ => diags = true
      }
    }
    diags
  }

  def run(transpile: bool, args: Array<string>): unit = {
    val firstFile = if (transpile) 2 else 1
    val numTrees = args.length - firstFile
    val outputFile = args(firstFile - 1)
    printLogo()
    val trees = new Array<SyntaxTree>(numTrees)
    for (x <- firstFile to (args.length - 1)) {
      print("parsing " + args(x) + "...")
      trees(x - firstFile) = MakeSyntaxTree.parseFile(args(x))
      println("done")
    }

    // verify no diagnostics from parse trees
    if (hasDiagnostics(trees)) {
      for (i <- 0 to (trees.length - 1)) {
        printDiagnostics(trees(i).diagnostics)
      }
    } else {
      val compilation = MakeCompilation.create(trees)
      compilation.diagnostics match {
        case Diagnostics.Empty =>
          if (transpile) {
            println("transpiling to " + outputFile + "...")
            compilation.transpile(outputFile)
          } else {
            compilation.printSymbols()
            println("emitting to " + outputFile + "...")
            compilation.emit(outputFile)
          }

        case diags =>
          printDiagnostics(diags)
      }
    }
  }
  
  def printDiagnostics(diagnostics: Diagnostics): unit =
    diagnostics match {
      case Diagnostics.Empty => ()
      case Diagnostics.Node(left, head, right) =>
        printDiagnostics(left)
        printDiagnostic(head)
        printDiagnostics(right)
    }
  

  def printDiagnostic(diagnostic: Diagnostic): unit = {
    val location = diagnostic.location
    val span = location.span
    val sourceFile = location.sourceFile

    println(diagnostic.toString())

    for (currentLine <- location.startLine to location.endLine) {
      val line = sourceFile.getLine(currentLine)
      val startInCurrent = sourceFile.getLineIndex(span.start) == currentLine
      val endInCurrent = sourceFile.getLineIndex(span.end) == currentLine

      val prefixEnd =
        if (startInCurrent) span.start
        else line.start

      val suffixStart =
        if (endInCurrent) span.end
        else line.end

      val prefixSpan = TextSpanFactory.fromBounds(line.start, prefixEnd)
      val errorSpan = TextSpanFactory.fromBounds(prefixEnd, suffixStart)
      val suffixSpan = TextSpanFactory.fromBounds(suffixStart, line.end)

      val prefix = sourceFile.toString(prefixSpan)
      val error = sourceFile.toString(errorSpan)
      val suffix = sourceFile.toString(suffixSpan)

      print(prefix)
      print(ANSI.foregroundColor("e06c75"))
      print(error)
      print(ANSI.Clear)
      println(suffix)

      for (c <- 0 to (prefixSpan.length - 2)) {
        print('-')
      }
      println('^')
    }

    println()
  }

  def printToken(token: SyntaxToken): unit =
    println(Pad.right("TOKEN[" + SyntaxFacts.getKindName(token.kind) + "," + string(token.start) + "]: ", 36, ' ') + "\"" + token.text + "\"")

  def printLogo(): unit = println("panther compiler - 0.0.1")

  def printHelp(): unit = {
    println("pncs output.c [sources]")
    println("pncs -t output/ [sources]")
  }
}