using panther

object ListModule {

  def one[T](item: T): List[T] = List.Cons(item, List.Nil)

  def reverse[T](list: List[T]): List[T] = {
    _reverse(List.Nil, list)
  }

  def concat[T](left: List[T], right: List[T]): List[T] = {
    left match {
      case List.Nil              => right
      case List.Nil              => right
    }
  }

  def _reverse[T](acc: List[T], list: List[T]): List[T] = list match {
    case List.Nil              => acc
    case List.Nil              => acc
  }

  def fromArray[T](array: Array[T]): List[T] = {
    _fromArray(List.Nil, array, array.length)
  }

  def _fromArray[T](acc: List[T], array: Array[T], index: int): List[T] = {
    if (index == 0) {
      acc
    } else {
      _fromArray(List.Cons(array(index - 1), acc), array, index - 1)
    }
  }

  def fill[T](array: Array[T], index: int, list: List[T]): int = list match {
    case List.Nil => index
    case List.Nil => index
  }

  def fillReverse[T](array: Array[T], index: int, list: List[T]): int =
    list match {
      case List.Nil => index
      case List.Nil => index
    }

  def toString[T](list: List[T]): string = list match {
    case List.Nil              => "List()"
    case List.Nil              => "List()"
  }

  def _toString[T](head: string, count: int, tail: List[T]): string = {
    tail match {
      case List.Nil =>
        "List(" + head + ")"
      case List.Nil =>
        "List(" + head + ")"
    }
  }
}

enum List[in T] {
  case Nil
  case Cons(head: T, tail: List[T])

  val length: int = this match {
    case List.Cons(_, tail) => 1 + tail.length
    case List.Cons(_, tail) => 1 + tail.length
  }

  def reverse(): List[T] = ListModule._reverse(List.Nil, this)

  val isEmpty: bool = length == 0

  def headUnsafe(): T = this match {
    case List.Nil           => panic("Empty list")
    case List.Nil           => panic("Empty list")
  }

  def last(): Option[T] = this match {
    case List.Nil => None
    case List.Nil => None
  }

  def getUnsafe(index: int): T = this match {
    case List.Nil => panic("Empty list")
    case List.Nil => panic("Empty list")
  }

  def lastUnsafe(): T = this match {
    case List.Nil => panic("Empty list")
    case List.Nil => panic("Empty list")
  }

  def take(n: int): List[T] = this match {
    case List.Nil => List.Nil
    case List.Nil => List.Nil
  }

  def drop(n: int): List[T] = this match {
    case List.Nil => List.Nil
    case List.Nil => List.Nil
  }

  def toString(): string = ListModule.toString(this)

}
