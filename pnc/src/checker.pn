using Type.Reference
using panther

// object TypeSchemeKind {
//     val Polymorphic = 1
//     val Simple = 2
// }

// class TypeScheme(kind: int, polymorphic: Array[PolymorphicType], simple: Array[SimpleType])

// class PolymorphicType(body: SimpleType)

// object SimpleTypeKind {
//     val Variable = 1
//     val Concrete = 2
// }
// class SimpleType(kind: int, variable: Array[Variable], concrete: Array[ConcreteType]) {
//     def is_any(): bool = kind == SimpleTypeKind.Concrete && concrete[0].kind == ConcreteTypeKind.Any
//     def is_nothing(): bool = kind == SimpleTypeKind.Concrete && concrete[0].kind == ConcreteTypeKind.Nothing
// }

// object ConcreteTypeKind {
//     val Any = 1 // Top
//     val Nothing = 2 // Bottom
//     val Function = 3
//     val Record = 4
//     val Primitive = 5
//     val Array = 5
// }

// class ConcreteType(
//     kind: int,
//     function: Array[Function],
//     record: Array[Record],
//     primitive: Array[Primitive],
//     variable: Array[Variable]
// )

// class Function(params: Array[SimpleType], returnType: SimpleType)
// class Array(type: Type)
// class RecordField(name: string, type: SimpleType)
// class Record(fields: Array[RecordField])
// class Primitive(name: string)
// class Variable(lower: ConcreteType, upper: ConcreteType) {
//     def lower_bound(): SimpleType = {}
//     def upper_bound(): SimpleType = { panic() }
//     def as_type_var(): Type = {}
// }

// Any is Top (super type of all types)
// Nothing is Bottom (sub type of all types)

// https://github.com/LPTK/simpler-sub/blob/simpler-sub/shared/src/main/scala/simplesub/Typer.scala

// ∩ == intersection
// ∪ == union
//
// https://www.youtube.com/watch?v=d10q-b8jNKg
// x gets type variable A
// y gets type variable B

// union of branches gets type variable C

// constraint: A <= int
// constraint: B <= int
// constraint: A, B <= C

// f: A -> B -> C where A <= int, B <= int, A ∪ B <= C
// then (coalesce bounds)
// f: A ∩ int -> B ∩ int -> A ∪ B ∪ C
// then simplify variables
// f: A ∩ int -> A ∩ int -> A


// will be connected to a Declaration or an Expression
class NodeLinks() {
  var _symbol: Option<Symbol> = None

  def has_symbol(): bool = _symbol.isDefined

  def get_symbol(): Symbol = _symbol.get

  def set_symbol(symbol: Symbol): Symbol = {
    _symbol = Some(symbol)
    symbol
  }

  var _type: Option<Type> = None

  def has_type(): bool = _type.isDefined

  def get_type(): Type = _type.get

  def set_type(typ: Type): Type = {
    _type = Some(typ)
    typ
  }
}

class TypeLinks() {
  var resolved: bool = false
  var resolving: bool = false
}


class Checker(diagnosticBag: DiagnosticBag, root: Symbol) {

  var last_symbol_id = 0
  var symbol_links = new Array<SymbolLinks>(10)
  var last_node_id = 0
  var node_links = new Array<NodeLinks>(10)
  var last_type_id = 0
  var type_links = new Array<TypeLinks>(10)
  val binaryOperators = new BinaryOperators()

  // string
  val stringSymbol = new Symbol(SymbolKind.Class, SymbolFlags.None, "string", TextLocationFactory.empty(), Some(root))
  val stringType = Type.Reference(stringSymbol, None)
  root.members.addSymbol(stringSymbol)
  setSymbolType(stringSymbol, stringType)

  // int
  val intSymbol = new Symbol(SymbolKind.Class, SymbolFlags.None, "int", TextLocationFactory.empty(), Some(root))
  val intType = Type.Reference(intSymbol, None)
  root.members.addSymbol(intSymbol)
  setSymbolType(intSymbol, intType)

  // char
  val charSymbol = new Symbol(SymbolKind.Class, SymbolFlags.None, "char", TextLocationFactory.empty(), Some(root))
  val charType = Type.Reference(charSymbol, None)
  root.members.addSymbol(charSymbol)
  setSymbolType(charSymbol, charType)

  // bool
  val boolSymbol = new Symbol(SymbolKind.Class, SymbolFlags.None, "bool", TextLocationFactory.empty(), Some(root))
  val boolType = Type.Reference(boolSymbol, None)
  root.members.addSymbol(boolSymbol)
  setSymbolType(boolSymbol, boolType)
  
  // None
  val noneSymbol = new Symbol(SymbolKind.Class, SymbolFlags.None, "None", TextLocationFactory.empty(), Some(root))
  val noneType = Type.Option(Type.Never)
  root.members.addSymbol(noneSymbol)
  setSymbolType(noneSymbol, noneType)

  // string.length: int
  val length = new Symbol(SymbolKind.Field, SymbolFlags.None, "length", TextLocationFactory.empty(), Some(stringSymbol))
  stringSymbol.members.addSymbol(length)
  setSymbolType(length, intType)

  val args = new Array<TypedParameter>(1)
  args(0) = TypedParameter("message", stringType)

  // println(message: string): unit
  val printlnSymbol = new Symbol(SymbolKind.Method, SymbolFlags.Static, "println", TextLocationFactory.empty(), Some(root))
  val printlnMessage = new Symbol(SymbolKind.Parameter, SymbolFlags.None, "message", TextLocationFactory.empty(), Some(printlnSymbol))
  printlnSymbol.members.addSymbol(printlnMessage)
  root.members.addSymbol(printlnSymbol)

  setSymbolType(printlnMessage, stringType)
  setSymbolType(printlnSymbol, Type.Function(args, Type.unit))

  // print(message: string): unit
  val printSymbol = new Symbol(SymbolKind.Method, SymbolFlags.Static, "print", TextLocationFactory.empty(), Some(root))
  val printMessage = new Symbol(SymbolKind.Parameter, SymbolFlags.None, "message", TextLocationFactory.empty(), Some(printSymbol))
  printSymbol.members.addSymbol(printMessage)
  root.members.addSymbol(printSymbol)
  setSymbolType(printMessage, stringType)
  setSymbolType(printSymbol, Type.Function(args, Type.unit))
  

  // initialize binary operators
  simpleOp(intType, BinaryOperatorKind.Plus)
  simpleOp(intType, BinaryOperatorKind.Minus)
  simpleOp(intType, BinaryOperatorKind.Multiply)
  simpleOp(intType, BinaryOperatorKind.Divide)
  simpleOp(intType, BinaryOperatorKind.Modulus)
  equalityOp(intType, BinaryOperatorKind.Equals)
  equalityOp(intType, BinaryOperatorKind.NotEquals)
  equalityOp(intType, BinaryOperatorKind.LessThan)
  equalityOp(intType, BinaryOperatorKind.LessThanOrEqual)
  equalityOp(intType, BinaryOperatorKind.GreaterThan)
  equalityOp(intType, BinaryOperatorKind.GreaterThanOrEqual)
  equalityOp(boolType, BinaryOperatorKind.Equals)
  equalityOp(boolType, BinaryOperatorKind.NotEquals)
  equalityOp(stringType, BinaryOperatorKind.Equals)
  equalityOp(stringType, BinaryOperatorKind.NotEquals)
  
  def simpleOp(typ: Type, operator: BinaryOperatorKind): unit = binaryOperators.addOperator(BinaryOperator(typ, typ, operator, typ))

  def equalityOp(typ: Type, operator: BinaryOperatorKind): unit = binaryOperators.addOperator(BinaryOperator(typ, typ, operator, boolType))

  def check(functions: Array<BoundFunction>, fields: Array<BoundField>): unit = {
    checkClasses(root)
    // determine types for fields with type annotations
    println("checking field type annotations")
//    checkFields(fields)
    // determine types for functions parameters
    //    println("checking function parameter types and annotated return types")
    //    checkFunctionParameterTypes()
    // determine types for functions return types & fields without type annotations
    //    inferFieldTypes()
  }
  
  def checkClasses(symbol: Symbol): unit = {
    if(symbol.kind == SymbolKind.Class) {
      val links = getSymbolLinks(symbol)
      if(!links.has_type()) {
        links.set_type(Type.Reference(symbol, None))
      } else ()
    } else ()
    val symbols = symbol.members.symbols()
    for (i <- 0 to (symbols.length - 1)) {
      val symbol = symbols(i)
      
      checkClasses(symbol)
    }
  }


  def get_symbol_id(symbol: Symbol): int = {
    if (symbol.id != -1) {
      symbol.id
    } else {
      if (last_symbol_id + 1 >= symbol_links.length) {
        val newItems = new Array<SymbolLinks>((last_symbol_id + 1) * 2)
        for (i <- 0 to (last_symbol_id - 1)) {
          newItems(i) = symbol_links(i)
        }
        symbol_links = newItems
      } else {}

      symbol_links(last_symbol_id) = new SymbolLinks()
      symbol.id = last_symbol_id
      last_symbol_id = last_symbol_id + 1
      symbol.id
    }
  }

  def getSymbolLinks(symbol: Symbol): SymbolLinks = {
    val id = get_symbol_id(symbol)
    symbol_links(id)
  }

  def checkFields(fields: Array<BoundField>): unit = {
    for (i <- 0 to (fields.length - 1)) {
      inferSymbolType(fields(i).symbol)
    }
  }

  def getSymbolType(symbol: Symbol): Option<Type> = {
    val links = getSymbolLinks(symbol)
    if (links.has_type()) {
      Some(links.get_type())
    } else {
      None
    }
  }

  def checkAssignable(toType: Type, from: Type): Type = {
    if (toType == Type.Error || from == Type.Error) {
      Type.Error
    } else {
      toType match {
        case Type.Option(innerTo) =>
          from match {
            case Type.Option(innerFrom) =>
              checkAssignable(innerTo, innerFrom)
            case _ =>
              Type.Error
          }
        case Type.Array(innerTo) =>
          from match {
            case Type.Array(innerFrom) =>
              checkAssignable(innerTo, innerFrom)
            case _ =>
              Type.Error
          }
        case toType =>
          if(from == Type.Never) {
            toType
          } else if (toType != from) {
//            TODO: current issue is that we need to be able to assign an enum case to the base case
//    ie Type.Any to Type for example.
// one shortcut could be that we assign Type.Any the type `Type` instead of it having `Type.Any`
            print("checkAssignable ")
            AstPrinter.printType(toType)
            print(" != ")
            AstPrinter.printType(from)
            println()
            panic("")
            toType
          } else {
            toType
          }
      }
    }
  }

  def checkBinaryOperator(left: Type, right: Type, operator: BinaryOperatorKind): Type = {
    _checkBinaryOperator(0, left, right, operator)
  }

  def _checkBinaryOperator(i: int, left: Type, right: Type, operator: BinaryOperatorKind): Type =
    if (i >= binaryOperators.size) panic("todo")
    else {
      val op = binaryOperators.operators(i)
      if (op.left == left && op.right == right && op.operator == operator) {
        op.result
      } else {
        _checkBinaryOperator(i + 1, left, right, operator)
      }
    }

  //
  //    // def fresh_var(): Variable = new Variable(Nothing, Any)
  //
  //    def get_return_type_of_symbol(symbol: Symbol): Type = {
  //        val typ = getTypeOfSymbol(symbol)
  //        getReturnType(typ)
  //    }
  //
  //    def getReturnType(typ: Type): Type = {
  //        if (typ.kind == TypeKind.Function) {
  //            typ.function.get.returnType
  //        } else {
  //            panic("get_return_type expected function kind, found: " + string(typ.kind))
  //            Type.Error
  //        }
  //    }
  //
  //    def resolveTypeConstructor(ctor: TypeConstructor): bool = {
  //        var resolved = true
  //        for (i <- 0 to (ctor.parameters.length-1)) {
  //            resolved = resolved && resolveType(ctor.parameters(i))
  //        }
  //        resolved
  //    }
  //
  //    def resolveFunctionType(func: FunctionType): bool = {
  //        var resolved = true
  //        for (i <- 0 to (func.parameters.length-1)) {
  //            resolved = resolved && resolveType(func.parameters(i))
  //        }
  //        resolved && resolveType(func.returnType)
  //    }
  //
  //    def resolveArrayType(array: ArrayType): bool =
  //        resolveType(array.inner)
  //
  //    def resolveOptionType(option: OptionType): bool =
  //        resolveType(option.inner)
  //
  //    def resolveUnresolvedType(typ: Type): bool = {
  //        val symbol = typ.symbol.get
  //        val resolved = getTypeOfSymbol(symbol)
  //        if (resolved.kind == TypeKind.Unresolved) {
  //            // noop
  //            false
  //        } else {
  //            typ.id = resolved.id
  //            typ.kind = resolved.kind
  //            typ.typeConstructor = resolved.typeConstructor
  ////            typ.intersection = resolved.intersection
  //            typ.primitive = resolved.primitive
  //            typ.typeVariable = resolved.typeVariable
  //            typ.function = resolved.function
  //            typ.array = resolved.array
  //            typ.option = resolved.option
  //            val links = getTypeLinks(typ)
  //            links.resolved
  //        }
  //    }
  //
  //    def getTypeName(typ: Type): string = {
  //        if (typ.kind == TypeKind.Primitive) {
  //            typ.primitive.get.name
  //        } else if (typ.kind == TypeKind.TypeConstructor) {
  //            typ.symbol.get.name
  //        } else if (typ.kind == TypeKind.Array) {
  //            "Array<" + getTypeName(typ.array.get.inner) + ">"
  //        } else if (typ.kind == TypeKind.Option) {
  //            "Option<" + getTypeName(typ.option.get.inner) + ">"
  //        } else if (typ.kind == TypeKind.Function) {
  //            val params = typ.function.get.parameters.map(getTypeName).mkString(", ")
  //            val returnType = getTypeName(typ.function.get.returnType)
  //            s"($params) -> $returnType"
  //        } else {
  //            panic("getTypeName: " + typ.kind)
  //            "unknown"
  //        }
  //    }

  //  def resolveType(typ: Type): bool = {
  //    val links = getTypeLinks(typ)
  //
  //    val start = links.resolved
  //    val resolved = if (links.resolving || links.resolved || typ.kind == TypeKind.Primitive) {
  //      true
  //    } else {
  //      links.resolving = true
  //
  //      if (typ.kind == TypeKind.TypeConstructor) {
  //        resolveTypeConstructor(typ.typeConstructor.get)
  //      } else if (typ.kind == TypeKind.Array) {
  //        resolveArrayType(typ.array.get)
  //      } else if (typ.kind == TypeKind.Option) {
  //        resolveOptionType(typ.option.get)
  //      } else if (typ.kind == TypeKind.Function) {
  //        resolveFunctionType(typ.function.get)
  //      } else if (typ.kind == TypeKind.Unresolved) {
  //        resolveUnresolvedType(typ)
  //      } else {
  //        panic("resolve_type of kind " + string(typ.kind))
  //        false
  //      }
  //    }
  //
  //    if (links.resolved == start) {
  //
  //    } else {
  //      println("type resolved: " + string(links.resolved))
  //    }
  //    links.resolving = false
  //    links.resolved = resolved
  //    resolved
  //  }

  ////    def getTypeOfNode(node: Node): Type = {
  ////        val links = get_node_links(node)
  ////        if (links.has_type()) {
  ////            links.get_type()
  ////        } else if(links.has_symbol()) {
  ////            get_type_of_symbol(links.get_symbol())
  ////        } else {
  ////            // need to find the symbol of this node
  ////
  ////        }
  ////    }
  ////
  ////    def getTypeOfDeclaration(decl: Declaration): Type = {
  ////
  ////    }

  //  def getTypeOfSymbol(symbol: Symbol): Type = {
  //    val links = getSymbolLinks(symbol)
  //    if (links.has_type()) {
  //      links.get_type()
  //    } else if (symbol.has_declaration()) {
  //      val decl = symbol.declaration()
  //      val node_links = get_node_links(MakeNode.decl(decl))
  //      if (node_links.has_type()) {
  //        node_links.get_type()
  //      } else {
  //        if (links.typing) {
  //          // we are already trying to type this symbol so we need to short
  //          // circuit once we get the type we should be able to reattempt
  //          // resolving by updating the unresolved type
  //          MakeType.unresolved(symbol)
  //        } else {
  //          links.typing = true
  //          val typ = getTypeOfDeclaration(decl, symbol.members)
  //          links.typing = false
  //          node_links.set_type(typ)
  //          links.set_type(typ)
  //          print("resolving type for " + symbol.name + "... ")
  //          if (resolveType(typ)) {
  //            AstPrinter.printType(typ)
  //            println()
  //          } else {
  //            AstPrinter.printColor(ColorPalette.Error)
  //            println("failed")
  //            AstPrinter.printClear()
  //          }
  //          typ
  //        }
  //      }
  //    } else {
  //      panic("get_type_of_symbol: no declaration for symbol " + symbol.name)
  //      Type.Error
  //    }
  //  }
  //
  //    def get_type_of_node(node: Node, scope: Scope): Type = {
  //        if (node.is_decl()) {
  //            getTypeOfDeclaration(node.declaration.get, scope)
  //        } else {
  //            getTypeOfExpression(node.expression.get, scope)
  //        }
  //    }
  //
  //    def getTypeOfDeclaration(decl: Declaration, scope: Scope): Type = {
  //        if (decl.kind == DeclarationKind.Object) {
  //            getTypeOfObjectDeclaration(decl.object_declaration.get, scope)
  //        } else if (decl.kind == DeclarationKind.Class) {
  //            get_type_of_class_declaration(decl.class_declaration.get, scope)
  //        } else if (decl.kind == DeclarationKind.Method) {
  //            getTypeOfMethodDeclaration(decl.function_declaration.get, scope)
  //        } else if (decl.kind == DeclarationKind.Parameter) {
  //            get_type_of_parameter_declaration(decl.parameter_declaration.get, scope)
  //        } else if (decl.kind == DeclarationKind.Local) {
  //            get_type_of_local_declaration(decl.local_declaration.get, scope)
  //        } else if (decl.kind == DeclarationKind.Token) {
  //            getTypeOfToken(decl.token_declaration.get, scope)
  //        } else {
  //            panic("get_type_of_declaration")
  //            Type.Error
  //        }
  //    }
  //
  //    def getTypeOfObjectDeclaration(decl: ObjectDeclarationSyntax, scope: Scope): Type = {
  //        val name = scope.name()
  //        //        val fullName = if(name == "") cls.identifier.text else name + "." + cls.identifier.text
  //
  //        MakeType.typeConstructor(scope.parent.symbol.get, new TypeConstructor(name, new Array[Type](0)))
  ////        panic("get_type_of_object_declaration")
  ////        Type.Error
  //    }
  //
  //    def get_type_of_class_declaration(cls: ClassDeclarationSyntax, scope: Scope): Type = {
  //        val name = scope.name()
  ////        val fullName = if(name == "") cls.identifier.text else name + "." + cls.identifier.text
  //
  //        MakeType.typeConstructor(scope.parent.symbol.get, new TypeConstructor(name, new Array[Type](0)))
  //    }
  //
  //    def getTypeOfMethodDeclaration(decl: FunctionDeclarationSyntax, scope: Scope): Type = {
  //        val param_types = new Array[Type](decl.parameters.length)
  //        for (i <- 0 to (decl.parameters.length-1)) {
  //            param_types(i) = get_type_of_parameter_declaration(decl.parameters(i), scope)
  //        }
  //
  //        val returnType = if (decl.typeAnnotation.isDefined) {
  //            get_type_of_type_annotation(decl.typeAnnotation.get, scope)
  //        } else if (decl.body.isDefined) {
  //            getTypeOfExpression(decl.body.get.expression, scope)
  //        } else {
  //            Type.Error
  //        }
  //
  //        MakeType.function(scope.parent.symbol.get, param_types, returnType)
  //    }
  //
  //    def get_type_of_parameter_declaration(decl: ParameterSyntax, scope: Scope): Type =
  //        get_type_of_type_annotation(decl.typeAnnotation, scope)
  //
  //      def get_type_of_local_declaration(decl: VariableDeclarationStatementSyntax, scope: Scope): Type = {
  //          // check type annotation first
  //          if (decl.typeAnnotation.isDefined) {
  //              get_type_of_type_annotation(decl.typeAnnotation.get, scope)
  //          } else {
  //              getTypeOfExpression(decl.expression, scope)
  //          }
  //      }

  def getTypeOfExpression(expr: ExpressionSyntax, scope: Scope): Type = {
    expr match {
      case ExpressionSyntax.ArrayCreationExpression(value) => getTypeOfArrayCreationExpression(value, scope)
      case ExpressionSyntax.AssignmentExpression(value) => getTypeOfAssignmentExpression(value, scope)
      case ExpressionSyntax.BinaryExpression(value) => getTypeOfBinaryExpression(value, scope)
      case ExpressionSyntax.BlockExpression(value) => getTypeOfBlockExpression(value, scope)
      case ExpressionSyntax.CallExpression(value) => getTypeOfCallExpression(value, scope)
      case ExpressionSyntax.ForExpression(value) => getTypeOfForExpression(value, scope)
      case ExpressionSyntax.GroupExpression(value) => getTypeOfGroupExpression(value, scope)
      case ExpressionSyntax.IdentifierName(value) => getTypeOfIdentifierName(value, scope)
      case ExpressionSyntax.IfExpression(value) => getTypeOfIfExpression(value, scope)
      case ExpressionSyntax.IndexExpression(value) => getTypeOfIndexExpression(value, scope)
      case ExpressionSyntax.LiteralExpression(value) => getTypeOfLiteralExpression(value, scope)
      case ExpressionSyntax.MemberAccessExpression(value) => getTypeOfMemberAccessExpression(value, scope)
      case expr: ExpressionSyntax.MatchExpression => getTypeOfMatchExpression(expr, scope)
      case ExpressionSyntax.NewExpression(value) => getTypeOfNewExpression(value, scope)
      case ExpressionSyntax.UnaryExpression(value) => getTypeOfUnaryExpression(value, scope)
      case ExpressionSyntax.UnitExpression(value) => getTypeOfUnitExpression(value, scope)
      case ExpressionSyntax.WhileExpression(value) => getTypeOfWhileExpression(value, scope)
    }
  }

  def getTypeOfArrayCreationExpression(value: ArrayCreationExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfAssignmentExpression(value: AssignmentExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfBinaryExpression(value: BinaryExpressionSyntax, scope: Scope): Type = {
    val left = getTypeOfExpression(value.left, scope)
    val right = getTypeOfExpression(value.right, scope)

    val operator = getOperator(value.operator.text)
    val result = checkBinaryOperator(left, right, operator)

    AstPrinter.printType(left)
    print(" " + value.operator.text + " ")
    AstPrinter.printType(right)
    print(" -> ")
    AstPrinter.printType(result)
    println()
    result
  }

  def getOperator(text: string): BinaryOperatorKind =
    text match {
      case "+" => BinaryOperatorKind.Plus
      case "-" => BinaryOperatorKind.Minus
      case "*" => BinaryOperatorKind.Multiply
      case "/" => BinaryOperatorKind.Divide
      case "%" => BinaryOperatorKind.Modulus
      case "==" => BinaryOperatorKind.Equals
      case "!=" => BinaryOperatorKind.NotEquals
      case "<" => BinaryOperatorKind.LessThan
      case "<=" => BinaryOperatorKind.LessThanOrEqual
      case ">" => BinaryOperatorKind.GreaterThan
      case ">=" => BinaryOperatorKind.GreaterThanOrEqual
      case "&&" => BinaryOperatorKind.LogicalAnd
      case "||" => BinaryOperatorKind.LogicalOr
      case _ =>
        panic("unexpected operator")
        BinaryOperatorKind.Unknown
    }

  def getTypeOfBlockExpression(value: BlockExpressionSyntax, scope: Scope): Type = {
    value.block.expression match {
      case Some(value) => getTypeOfExpression(value, scope)
      case None => Type.unit
    }
  }

  def getTypeOfCallExpression(value: CallExpressionSyntax, scope: Scope): Type = {
    val function = getTypeOfExpression(value.name, scope)
    val arguments = value.arguments

    applyCallExpression(function, arguments, scope)
  }

  private def applyCallExpression(function: Type, arguments: ExpressionListSyntax, scope: Scope): Type = {
    function match {
      case Type.Function(parameters, returnType) =>
        val typedArguments = new Array<Type>(arguments.expressions.length)
        for (i <- 0 to (arguments.expressions.length - 1)) {
          typedArguments(i) = getTypeOfExpression(arguments.expressions(i).expression, scope)
        }
        if (parameters.length == typedArguments.length) {
          for (i <- 0 to (parameters.length - 1)) {
            checkAssignable(parameters(i).typ, typedArguments(i))
          }
          returnType
        } else {
          panic("getTypeOfCallExpression: parameter count mismatch")
          Type.Error
        }
      case Type.Reference(symbol, _) =>
        // this is a class so lets look for a ctor
        val ctor = symbol.members.get(".ctor")
        ctor match {
          case Some(value) =>
            val function = inferSymbolType(value)
            applyCallExpression(function, arguments, scope)
          case None =>
            println("no ctor for type: " + symbol.fullName())
            panic("applyCallExpression")
        }
      case Type.Error => Type.Error
      case _ =>
        print("unexpected type: ")
        AstPrinter.printType(function)
        println()
        panic("applyCallExpression")
    }
  }

  def getTypeOfForExpression(value: ForExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfGroupExpression(value: GroupExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfIdentifierName(value: SimpleNameSyntax.IdentifierNameSyntax, scope: Scope): Type = {
    scope.get(value.identifier.text) match {
      case Some(symbol) =>
        val links = getSymbolLinks(symbol)
        if (links.has_type()) {
          links.get_type()
        } else {
          // maybe the binder should track all items that define a declaration rather than specific types
          // we can build Nodes that represent the declaration and then we can track the type of the node
          // as well as the symbol that the node is associated with

          //          panic(symbol.location.to_string() + " getTypeOfIdentifierName: no type for symbol " + symbol.fullName())
          //          Type.Error
          Type.Reference(symbol, None)
        }
      case None =>
        diagnosticBag.reportTypeNotDefined(value.identifier.location, value.identifier.text)
        Type.Error
    }
    //    AstPrinter.printTokenInfo(value.identifier)
    //    panic("todo")
  }

  def getTypeOfIfExpression(value: IfExpressionSyntax, scope: Scope): Type = {
    checkAssignable(boolType, getTypeOfExpression(value.condition, scope))
    val thenExpr = getTypeOfExpression(value.thenExpr, scope)
    val elseExpr = getTypeOfExpression(value.elseExpr, scope)
    checkAssignable(thenExpr, elseExpr)
  }

  def getTypeOfIndexExpression(value: IndexExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfLiteralExpression(value: LiteralExpressionSyntax, scope: Scope): Type = {
    value.value.kind match {
      case SyntaxTokenValueKind.string => stringType
      case SyntaxTokenValueKind.Number => intType
      case SyntaxTokenValueKind.bool => boolType
      case SyntaxTokenValueKind.Character => charType
      case _ => panic("getTypeOfLiteralExpression: " + value.value.kind)
    }
  }

  def getTypeOfMemberAccessExpression(value: MemberAccessExpressionSyntax, scope: Scope): Type = {
    val left = getTypeOfExpression(value.left, scope)
    left match {
      case Reference(symbol, _) =>
        symbol.members.get(value.right.identifier.text) match {
          case Some(member) =>
            inferSymbolType(member)
          case None =>
            panic("todo")
            Type.Error
        }
      case option: Type.Option =>
        getOptionMemberType(option, value.right.identifier.text)
      case array: Type.Array =>
        getArrayMemberType(array, value.right.identifier.text)
      case _ =>
        print("unexpected type: ")
        AstPrinter.printType(left)
        panic("todo")
    }
  }

  def getOptionMemberType(option: Type.Option, member: string): Type = {
    member match {
      case "isDefined" => boolType
      case "get" => option.inner
      case _ => panic("unknown option member: " + member)
    }
  }

  def getArrayMemberType(option: Type.Array, member: string): Type =
    member match {
      case "length" => intType
      case _ =>
        panic("unknown array member: " + member)
        Type.Error
    }

  def getStringMemberType(member: string): Type = {
    member match {
      case "length" => intType
      case _ =>
        panic("unknown string member: " + member)
        Type.Error
    }
  }

  def inferSymbolType(symbol: Symbol): Type = {
    val links = getSymbolLinks(symbol)
    if (links.has_type()) {
      links.get_type()
    } else {
      if (symbol.kind == SymbolKind.Class) {
        links.set_type(Type.Reference(symbol, None))
      } else {
        val typ = inferTypeOfDeclaration(symbol, links, symbol.declaration())
        links.set_type(typ)

        //        inferTypeAnnotation(symbol, links) match {
        //          case Some(annotatedType) =>
        //            links.set_type(annotatedType)
        //            inferExpressionType(symbol, links) match {
        //              case Some(value) => checkAssignable(annotatedType, value)
        //              case None => annotatedType
        //            }
        //          case None =>
        //            inferFunctionType(symbol, links) match {
        //              case Some(value) => links.set_type(value)
        //              case None =>
        //                inferExpressionType(symbol, links) match {
        //                  case Some(value) => links.set_type(value)
        //                  case None =>
        //                    // TODO handle constructors
        //                    new SymbolTreePrinter(this).print_symbol(symbol)
        //                    printLocation(symbol.location)
        //                    panic("inferSymbolType: no type for symbol " + symbol.fullName())
        //                }
        //            }
        //        }
      }
    }
  }

  def inferTypeOfDeclaration(symbol: Symbol, links: SymbolLinks, declaration: Declaration): Type =
    declaration match {
      case Declaration.Class(name, location, value) => inferTypeOfClass(symbol, links, value)
      case Declaration.ClassFromObject(name, location, value) => inferTypeOfClassFromObject(symbol, links, value)
      case Declaration.ClassFromEnum(name, location, value) => inferTypeOfClassFromEnum(symbol, links, value)
      case Declaration.ClassFromEnumCase(name, location, value) => inferTypeOfClassFromEnumCase(symbol, links, value)
      case Declaration.Constructor(name, location, value) => inferTypeOfConstructorFromParameters(symbol, links, value)
      case Declaration.Method(name, location, value) => inferTypeOfMethod(symbol, links, value)
      case Declaration.FieldFromParameter(name, location, value) => inferTypeOfFieldFromParameter(symbol, links, value)
      case Declaration.FieldFromVariable(name, location, value) => inferTypeOfFieldFromVariable(symbol, links, value)
      case Declaration.Parameter(name, location, value) => inferTypeOfParameter(symbol, links, value)
      case Declaration.Local(name, location, value) => inferTypeOfLocal(symbol, links, value)
    }

  def inferTypeOfClass(symbol: Symbol, links: SymbolLinks, value: MemberSyntax.ClassDeclarationSyntax): Type = panic("todo")

  def inferTypeOfClassFromObject(symbol: Symbol, links: SymbolLinks, value: MemberSyntax.ObjectDeclarationSyntax): Type = panic("todo")

  def inferTypeOfClassFromEnum(symbol: Symbol, links: SymbolLinks, value: MemberSyntax.EnumDeclarationSyntax): Type = panic("todo")

  def inferTypeOfClassFromEnumCase(symbol: Symbol, links: SymbolLinks, value: EnumCaseSyntax): Type = panic("todo")

  def inferTypeOfConstructorFromParameters(symbol: Symbol, links: SymbolLinks, parameters: Array<ParameterSyntax>): Type = {
    val typedParameters: Array<TypedParameter> = inferTypedParameters(symbol, parameters)
    Type.Function(typedParameters, Type.Reference(symbol.parent(), None))
  }

  private def inferTypedParameters(symbol: Symbol, parameters: Array<ParameterSyntax>) = {
    val typedParameters = new Array<TypedParameter>(parameters.length)
    for (j <- 0 to (parameters.length - 1)) {
      val param = parameters(j)
      symbol.members.get(param.identifier.text) match {
        case Some(paramSymbol) =>
          val typ = inferSymbolType(paramSymbol)
          typedParameters(j) = TypedParameter(paramSymbol.name, typ)
        case None =>
          panic(" - no symbol for parameter " + param.identifier.text)
      }
    }
    typedParameters
  }

  def inferTypeOfMethod(symbol: Symbol, links: SymbolLinks, func: MemberSyntax.FunctionDeclarationSyntax): Type = {
    val parameters = inferTypedParameters(symbol, func.parameters)

    func.typeAnnotation match {
      case Some(typeAnnotation) =>
        val returnType = getTypeOfName(typeAnnotation.typ, symbol.members)
        Type.Function(parameters, returnType)
      case None =>
        // get expr and type it 
        panic("todo")
        Type.Error
    }
  }

  def inferTypeOfFieldFromParameter(symbol: Symbol, links: SymbolLinks, value: ParameterSyntax): Type =
    getTypeOfName(value.typeAnnotation.typ, symbol.members)

  def inferTypeOfFieldFromVariable(symbol: Symbol, links: SymbolLinks, value: VariableDeclarationStatementSyntax): Type = {
    val typ = getTypeOfExpression(value.expression, symbol.members)
    value.typeAnnotation match {
      case Some(value) =>
        val typeAnnotation = getTypeOfName(value.typ, symbol.members)
        checkAssignable(typeAnnotation, typ)
        typeAnnotation
      case None =>
        typ
    }
  }

  def inferTypeOfParameter(symbol: Symbol, links: SymbolLinks, value: ParameterSyntax): Type =
    getTypeOfName(value.typeAnnotation.typ, symbol.members)

  def inferTypeOfLocal(symbol: Symbol, links: SymbolLinks, value: VariableDeclarationStatementSyntax): Type = panic("todo")

  def printSymbolType(note: string, symbol: Symbol, typ: Type): unit = {
    print(note + symbol.fullName() + ": ")
    AstPrinter.printType(typ)
    println()
  }

  def getTypeOfMatchExpression(expression: ExpressionSyntax.MatchExpression, scope: Scope): Type = panic("todo")

  def getTypeOfNewExpression(value: NewExpressionSyntax, scope: Scope): Type =
    getTypeOfName(value.name, scope)

  def getTypeOfUnaryExpression(value: UnaryExpressionSyntax, scope: Scope): Type =
    getTypeOfExpression(value.expression, scope)

  def getTypeOfUnitExpression(value: UnitExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfWhileExpression(value: WhileExpressionSyntax, scope: Scope): Type = panic("todo")

  //
  //    def get_type_of_array_creation_expression(expr: ArrayCreationExpressionSyntax, scope: Scope): Type = {
  //        val inner = get_type_of_name(expr.name, scope)
  //        MakeType.array(inner)
  //    }
  //
  //    def get_type_of_assignment_expression(expr: AssignmentExpressionSyntax, scope: Scope): Type = {
  //        val left = getTypeOfExpression(expr.left, scope)
  //        val right = getTypeOfExpression(expr.right, scope)
  //        if (left == right) {
  //            UnitType
  //        } else {
  //            panic("invalid assignment")
  //            Type.Error
  //        }
  //    }
  //
  //    def getTypeOfBinaryExpression(expr: BinaryExpressionSyntax, scope: Scope): Type = {
  //        val lhs = getTypeOfExpression(expr.left, scope)
  //        val rhs = getTypeOfExpression(expr.right, scope)
  //        val lhsName = getTypeName(lhs)
  //        val rhsName = getTypeName(rhs)
  //        val op = expr.operator.text
  //        val intint = lhsName == "int" && rhsName == "int"
  //        if(intint && (op == "+" || op == "-" || op == "*" || op == "/" || op == "%")) {
  //            lhs
  //        } else {
  //            panic("get_type_of_binary_expression: " + getTypeName(lhs) + " " + expr.operator.text + " " + getTypeName(rhs))
  //            Type.Error
  //        }
  //    }
  //
  //    def getTypeOfBlockExpression(expr: BlockExpressionSyntax, scope: Scope): Type = {
  //        // TODO: we need a better way to grab the block scope that associated to an expression
  //        val block = scope.getScopeByName("block")
  //        if(block.isEmpty) {
  //            panic("getTypeOfBlockExpression: block scope not found")
  //            Type.Error
  //        } else {
  //            val blockScope = block.get
  //            checkStatements(expr.statements, blockScope)
  //            if (expr.expression.isDefined) getTypeOfExpression(expr.expression.get, blockScope)
  //            else UnitType
  //        }
  //    }
  //
  //    def checkStatements(statements: Array[StatementSyntax], scope: Scope) = {
  //        for (i <- 0 to (statements.length-1)) {
  //            checkStatement(statements(i), scope)
  //        }
  //    }
  //
  //    def checkStatement(syntax: StatementSyntax, scope: Scope): unit = {
  //        if (syntax.kind == SyntaxKind.VariableDeclarationStatement) {
  //            checkVariableDeclarationStatement(syntax.variableDeclarationStatement.get, scope)
  //        } else if (syntax.kind == SyntaxKind.ExpressionStatement) {
  //            checkExpressionStatement(syntax.expressionStatement.get, scope)
  //        } else ()
  //    }
  //
  //    def checkExpressionStatement(statement: ExpressionStatementSyntax, scope: Scope): unit = {
  //        getTypeOfExpression(statement.expression, scope)
  //    }
  //
  //    def checkVariableDeclarationStatement(statement: VariableDeclarationStatementSyntax, scope: Scope):unit = {
  //        if (statement.typeAnnotation.isDefined) {
  //            val typ = get_type_of_type_annotation(statement.typeAnnotation.get, scope)
  //            val rhs = getTypeOfExpression(statement.expression, scope)
  //            val symbol = scope.get(statement.identifier.text)
  //            if (symbol.isDefined) {
  //                // verify that rhs matched type annotation
  //                setSymbolType(symbol.get, typ)
  //            } else {
  //                panic("checkVariableDeclarationStatement: symbol not found by binder")
  //            }
  //        } else {
  //            getTypeOfExpression(statement.expression, scope)
  //        }
  //    }
  //
  //    def getTypeOfCallExpression(expr: CallExpressionSyntax, scope: Scope): Type = {
  //        val left = getTypeOfExpression(expr.name, scope)
  //        val arguments = getTypesOfExpressionList(expr.arguments, scope)
  //
  //        if (left.kind == TypeKind.Function) {
  //            val function = left.function.get
  //            val parameters = function.parameters
  //            if (parameters.length == arguments.length) {
  //                var error = false
  //                var i = 0
  //                 while(i < parameters.length - 1) {
  //                     if (parameters(i) != arguments(i)) {
  //                         error = true
  //                     } else ()
  //                     i = i + 1
  //                 }
  //                if (error) {
  //                    panic("getTypeOfCallExpression: parameter mismatch")
  //                    return Type.Error
  //                } else {
  //                    function.returnType
  //                }
  //            } else {
  //                panic("getTypeOfCallExpression: parameter count mismatch")
  //                Type.Error
  //            }
  //        } else if (left.kind == TypeKind.Array) {
  //            // confirm only one argument
  //            if (arguments.length != 1) {
  //                panic("getTypeOfCallExpression: array method expects one argument")
  //                Type.Error
  //            } else {
  //                val arg = arguments(0)
  //                if (arg != IntType) {
  //                    panic("getTypeOfCallExpression: array method expects int argument")
  //                } else {
  //                    left.array.get.inner
  //                }
  //            }
  //        } else {
  //            panic("expected function type, found: " + getTypeName(left))
  //            Type.Error
  //        }
  //    }
  //
  //    def getTypesOfExpressionList(arguments: ExpressionListSyntax, scope: Scope): Array[Type] = {
  //        val types = new Array[Type](arguments.expressions.length)
  //        for (i <- 0 to (arguments.expressions.length-1)) {
  //            types(i) =            getTypeOfExpression(arguments.expressions(i).expression, scope)
  //        }
  //        types
  //    }
  //
  //    def getTypeOfForExpression(expr: ForExpressionSyntax, scope: Scope): Type = {
  //        // TODO: this only supports one for loop in a given method currently
  //        val maybeForScope = scope.getScopeByName("for")
  //        if(maybeForScope.isEmpty) {
  //            panic("getTypeOfForExpression: for scope not found")
  //            Type.Error
  //        } else {
  //            val forScope = maybeForScope.get
  //            val variable = expr.identifier.text
  //
  //            val symbol = forScope.get(variable)
  //            if(symbol.isEmpty) {
  //                panic("getTypeOfForExpression: symbol not found")
  //                Type.Error
  //            } else {
  //                setSymbolType(symbol.get, IntType)
  //
  //                getTypeOfExpression(expr.fromExpr, forScope)
  //                getTypeOfExpression(expr.toExpr, forScope)
  //                getTypeOfExpression(expr.body, forScope)
  //
  //                UnitType
  //            }
  //        }
  //    }
  //    def get_type_of_group_expression(expr: GroupExpressionSyntax, scope: Scope): Type =
  //        getTypeOfExpression(expr.expression, scope)
  //
  //    def getTypeOfIdentifierName(expr: IdentifierNameSyntax, scope: Scope): Type =
  //        getTypeOfToken(expr.identifier, scope)
  //
  //    def getTypeOfIfExpression(expr: IfExpressionSyntax, scope: Scope): Type = {
  //        val lhs = getTypeOfExpression(expr.thenExpr, scope)
  //        val rhs = getTypeOfExpression(expr.elseExpr, scope)
  //        if(lhs == rhs) lhs
  //        else {
  //            panic("get_type_of_if_expression")
  //            Type.Error
  //        }
  //    }
  //    def get_type_of_index_expression(expr: IndexExpressionSyntax): Type = {
  //        panic("get_type_of_index_expression")
  //        Type.Error
  //    }
  //    def get_type_of_literal_expression(expr: LiteralExpressionSyntax): Type = {
  //        if (expr.value.kind == SyntaxTokenValueKind.Boolean) BoolType
  //        else if (expr.value.kind == SyntaxTokenValueKind.String) StringType
  //        else if (expr.value.kind == SyntaxTokenValueKind.Character) CharType
  //        else if (expr.value.kind == SyntaxTokenValueKind.Number) IntType
  //        else {
  //            panic("get_type_of_literal_expression of kind: " + string(expr.value.kind))
  //            Type.Error
  //        }
  //    }
  //
  //    def getTypeOfMemberAccessExpression(expr: MemberAccessExpressionSyntax, scope: Scope): Type = {
  //        val left = getTypeOfExpression(expr.left, scope)
  //        // special cases
  //        // 1. option
  //        // 2. array
  //        val memberName = expr.right.identifier.text
  //        if(left.kind == TypeKind.Option) {
  //            if(memberName == "get") {
  //                left.option.get.inner
  //            } else {
  //                panic("getTypeOfMemberAccessExpression: unknown member " + memberName)
  //                Type.Error
  //            }
  //        } else if (left.kind == TypeKind.Array) {
  //            if(memberName == "length") {
  //                IntType
  //            } else {
  //                panic("getTypeOfMemberAccessExpression: unknown member " + memberName)
  //                Type.Error
  //            }
  //
  //        } else {
  //            val method = left.symbol.get.members.get(memberName)
  //            if(method.isDefined) getTypeOfSymbol(method.get)
  //            else {
  //                panic("getTypeOfMemberAccessExpression")
  //                Type.Error
  //            }
  //        }
  //    }
  //
  //    def get_type_of_new_expression(expr: NewExpressionSyntax, scope: Scope): Type =
  //        get_type_of_name(expr.name, scope)
  //
  //    def get_type_of_unary_expression(expr: UnaryExpressionSyntax, scope: Scope): Type = {
  //        val rhs = getTypeOfExpression(expr.expression, scope)
  //        if (expr.operator.text == "-") {
  //            if (rhs.kind == TypeKind.Primitive && rhs.primitive.get.name == "int") {
  //                IntType
  //            } else if (rhs.kind == TypeKind.Primitive) {
  //                printLocation(expr.operator.location)
  //                panic("get_type_of_unary_expression: unknown primitive " + rhs.primitive.get.name)
  //                Type.Error
  //            } else {
  //                panic("get_type_of_unary_expression: unknown rhs.kind " + string(rhs.kind))
  //                Type.Error
  //            }
  //        } else {
  //            panic("get_type_of_unary_expression: unknown operator " + expr.operator.text)
  //            Type.Error
  //        }
  //    }
  //
  //    def get_type_of_unit_expression(expr: UnitExpressionSyntax): Type = {
  //        panic("get_type_of_unit_expression")
  //        Type.Error
  //    }
  //
  //    def get_type_of_while_expression(expr: WhileExpressionSyntax): Type = {
  //        panic("get_type_of_while_expression")
  //        Type.Error
  //    }
  //
  //    def get_type_of_type_annotation(typ: TypeAnnotationSyntax, scope: Scope): Type =
  //        get_type_of_name(typ.typ, scope)

  def getTypeOfToken(token: SyntaxToken, scope: Scope): Type =
    getTypeOfString(token.text, token.location, scope)

  def getTypeOfString(name: string, location: TextLocation, scope: Scope): Type = {
    val scalaType = if (location.source_file.isScala()) {
      if (name == "String") {
        stringType
      } else if (name == "Int") {
        intType
      } else if (name == "Char") {
        charType
      } else if (name == "Boolean") {
        boolType
      } else if (name == "Unit") {
        Type.unit
      } else {
        Type.Error
      }
    } else Type.Error

    if (scalaType != Type.Error) {
      scalaType
    } else if (name == "int") {
      intType
    } else if (name == "char") {
      charType
    } else if (name == "string") {
      stringType
    } else if (name == "bool") {
      boolType
    } else if (name == "any") {
      Type.Any
    } else if (name == "unit") {
      Type.unit
    } else {
      val result = scope.get(name)
      if (result.isDefined) {
        Type.Reference(result.get, None)
      } else {
        panic("getTypeOfString: " + name)
        diagnosticBag.reportTypeNotDefined(location, name)
        Type.Error
      }
    }
  }

  def getTypeOfName(name: NameSyntax, scope: Scope): Type = {
    name match {
      case NameSyntax.SimpleName(name) =>
        getTypeOfSimpleName(name, scope)
      case NameSyntax.QualifiedNameSyntax(left, dotToken, right) =>
        getTypeOfQualifiedName(left, dotToken, right, scope)
    }
  }

  def getTypeOfSimpleName(name: SimpleNameSyntax, scope: Scope): Type = {
    name match {
      case SimpleNameSyntax.GenericNameSyntax(identifier, typeArgumentList) =>
        getTypeOfGenericName(identifier, typeArgumentList, scope)
      case SimpleNameSyntax.IdentifierNameSyntax(identifier) =>
        getTypeOfToken(identifier, scope)
      case _: SimpleNameSyntax.AliasSyntax => ???
      case _: SimpleNameSyntax.ScalaAliasSyntax => ???
    }
  }

  def getTypeOfGenericName(identifier: SyntaxToken,
                           typeArgumentlist: TypeArgumentListSyntax, scope: Scope): Type = {
    // HACK: the SArray is a hack until we can get using lookups in place
    if (identifier.text == "Array" || identifier.text == "SArray") {
      if (typeArgumentlist.arguments.length == 1) {
        val inner = getTypeOfName(typeArgumentlist.arguments(0).name, scope)
        Type.Array(inner)
      } else {
        panic("Expected Array of rank 1, found rank " + string(typeArgumentlist.arguments.length))
        Type.Error
      }
    // HACK: the SOption is a hack until we can get using lookups in place
    } else if (identifier.text == "Option" || identifier.text == "SOption") {
      if (typeArgumentlist.arguments.length == 1) {
        val inner = getTypeOfName(typeArgumentlist.arguments(0).name, scope)
        Type.Option(inner)
      } else {
        panic("Expected Option with one type parameter, found " + string(typeArgumentlist.arguments.length))
        Type.Error
      }
    } else {
      printLocation(identifier.location)
      panic("Expected Array or Option, found: '" + identifier.text + "'")
      Type.Error
    }
  }

  def getTypeOfQualifiedName(left: NameSyntax, dotToken: SyntaxToken, right: SimpleNameSyntax, scope: Scope): Type = {
    val leftType = getTypeOfName(left, scope)
    leftType match {
      case Type.Reference(symbol, _) =>
        getTypeOfSimpleName(right, symbol.members)
      case Type.Error => Type.Error
      case _ => panic("Expected reference type, found: " + leftType)
    }
  }
  //
  //    def get_type_of_class_symbol(symbol: Symbol): Type = {
  //        panic("get_type_of_class_symbol")
  //        Type.Error
  //    }
  //    def get_type_of_method_symbol(symbol: Symbol): Type = {
  //        panic("get_type_of_method_symbol")
  //        Type.Error
  //    }
  //    def get_type_of_field_symbol(symbol: Symbol): Type = {
  //        panic("get_type_of_field_symbol")
  //        Type.Error
  //    }
  //    def get_type_of_parameter_symbol(symbol: Symbol): Type = {
  //        panic("get_type_of_parameter_symbol")
  //        Type.Error
  //    }
  //    def get_type_of_local_symbol(symbol: Symbol): Type = {
  //        panic("get_type_of_local_symbol")
  //        Type.Error
  //    }
  //
  //
  //  def get_node_id(node: Node): int = {
  //    if (node.id() != -1) {
  //      node.id()
  //    } else {
  //      if (last_node_id + 1 >= node_links.length) {
  //        val newItems = new Array[NodeLinks]((last_node_id + 1) * 2)
  //        for (i <- 0 to (last_node_id - 1)) {
  //          newItems(i) = node_links(i)
  //        }
  //        node_links = newItems
  //      } else {}
  //
  //      node_links(last_node_id) = new NodeLinks()
  //      node.set_id(last_node_id)
  //      last_node_id = last_node_id + 1
  //      node.id()
  //    }
  //  }

  //  def get_node_links(node: Node): NodeLinks = {
  //    val id = get_node_id(node)
  //    node_links(id)
  //  }


  //  def get_type_id(typ: Type): int = {
  //    if (typ.id != -1) {
  //      typ.id
  //    } else {
  //      if (last_type_id + 1 >= type_links.length) {
  //        val newItems = new Array[TypeLinks]((last_type_id + 1) * 2)
  //        for (i <- 0 to (last_type_id - 1)) {
  //          newItems(i) = type_links(i)
  //        }
  //        type_links = newItems
  //      } else {}
  //
  //      type_links(last_type_id) = new TypeLinks()
  //      typ.id = last_type_id
  //      last_type_id = last_type_id + 1
  //      typ.id
  //    }
  //  }

  //  def getTypeLinks(typ: Type): TypeLinks = {
  //    val id = get_type_id(typ)
  //    type_links(id)
  //  }

  //

  def printLocation(location: TextLocation): unit = {
    val span = location.span
    val source_file = location.source_file

    for (currrent_line <- location.start_line to location.end_line) {
      val line = source_file.get_line(currrent_line)
      val start_in_current = source_file.get_line_index(span.start) == currrent_line
      val end_in_current = source_file.get_line_index(span.end) == currrent_line

      val prefix_end =
        if (start_in_current) span.start
        else line.start

      val suffix_start =
        if (end_in_current) span.end
        else line.end

      val prefix_span = TextSpanFactory.from_bounds(line.start, prefix_end)
      val error_span = TextSpanFactory.from_bounds(prefix_end, suffix_start)
      val suffix_span = TextSpanFactory.from_bounds(suffix_start, line.end)

      val prefix = source_file.to_string(prefix_span)
      val error = source_file.to_string(error_span)
      val suffix = source_file.to_string(suffix_span)

      print(prefix)
      print(ANSI.foregroundColor("e06c75"))
      print(error)
      print(ANSI.Clear)
      println(suffix)

      for (c <- 0 to (prefix_span.length - 1)) {
        print('-')
      }
      println('^')
    }

    println()
  }
  //
  //    // // convert an inferred SimpleType into the immutable type representation
  //    // def coalesce_type(simple: SimpleType): Type =
  //    //     coalesce_type(simple, true)
  //
  //    // def coalesce_type(simple: SimpleType, polarity: bool): Type = {
  //    //     if (simple.kind == SimpleTypeKind.Variable) {
  //    //         val tv = simple.variable[0]
  //    //         val bound = if (polarity) tv.lower_bound() else tv.upper_bound()
  //    //         val bound_type = coalesce_type(bound, polarity)
  //    //         if (polarity && bound.is_nothing() || bound.is_any()) tv.as_type_var()
  //    //         else if (polarity) MakeType.union(tv.as_type_var(), bound_type)
  //    //         else MakeType.intersection(tv.as_type_var(), bound_type)
  //    //     } else {
  //    //         val concrete = simple.concrete[0]
  //    //         if (concrete.kind == ConcreteTypeKind.Function) {
  //    //             MakeType.function(
  //    //                 concrete.function[0].symbol,
  //    //                 coalesce_types(concrete.function[0].params, !polarity),
  //    //                 coalesce_type(concrete.function[0].returnType, polarity)
  //    //             )
  //    //         } else if (concrete.kind == ConcreteTypeKind.Record) {
  //    //             MakeType.record(concrete.record[0].symbol, coalesce_record(concrete.record[0], polarity))
  //    //         } else if (concrete.kind == ConcreteTypeKind.Primitive) {
  //    //             MakeType.primitive(concrete.primitive[0].name)
  //    //         } else if (concrete.kind == ConcreteTypeKind.Any) {
  //    //             MakeType.top
  //    //         } else // if (concrete.kind == ConcreteTypeKind.Nothing) {
  //    //             MakeType.bottom
  //    //         }
  //    // }
  //
  //    // def coalesce_types(simple_types: Array[SimpleType], polarity: bool): Array[Type] = {
  //    //     val types = new Type[simple_types.length]
  //    //     for (x <- 0 to simple_types.length) {
  //    //         types(x) = coalesce_type(simple_types(x), polarity)
  //    //     }
  //    //     types
  //    // }
  //
  //    // def coalesce_record(record: Record, polarity: bool): RecordType = {
  //    //     val fields = new RecordTypeField[record.fields.length]
  //    //     for (x <- 0 to record.fields.length) {
  //    //         fields(x) = coalesce_record_field(record.fields(x), polarity)
  //    //     }
  //    //     new RecordType(fields)
  //    // }
  //
  //    // def coalesce_record_field(field: RecordField, polarity: bool): RecordTypeField =
  //    //     new RecordTypeField(field.name, coalesce_type(field.type, polarity))
  //

  def setSymbolType(symbol: Symbol, value: Type) = {
    val links = getSymbolLinks(symbol)
    links.set_type(value)
  }
}