using Type.Reference
using panther

// object TypeSchemeKind {
//     val Polymorphic = 1
//     val Simple = 2
// }

// class TypeScheme(kind: int, polymorphic: Array[PolymorphicType], simple: Array[SimpleType])

// class PolymorphicType(body: SimpleType)

// object SimpleTypeKind {
//     val Variable = 1
//     val Concrete = 2
// }
// class SimpleType(kind: int, variable: Array[Variable], concrete: Array[ConcreteType]) {
//     def is_any(): bool = kind == SimpleTypeKind.Concrete && concrete[0].kind == ConcreteTypeKind.Any
//     def is_nothing(): bool = kind == SimpleTypeKind.Concrete && concrete[0].kind == ConcreteTypeKind.Nothing
// }

// object ConcreteTypeKind {
//     val Any = 1 // Top
//     val Nothing = 2 // Bottom
//     val Function = 3
//     val Record = 4
//     val Primitive = 5
//     val Array = 5
// }

// class ConcreteType(
//     kind: int,
//     function: Array[Function],
//     record: Array[Record],
//     primitive: Array[Primitive],
//     variable: Array[Variable]
// )

// class Function(params: Array[SimpleType], returnType: SimpleType)
// class Array(type: Type)
// class RecordField(name: string, type: SimpleType)
// class Record(fields: Array[RecordField])
// class Primitive(name: string)
// class Variable(lower: ConcreteType, upper: ConcreteType) {
//     def lower_bound(): SimpleType = {}
//     def upper_bound(): SimpleType = { panic() }
//     def as_type_var(): Type = {}
// }

// Any is Top (super type of all types)
// Nothing is Bottom (sub type of all types)

// https://github.com/LPTK/simpler-sub/blob/simpler-sub/shared/src/main/scala/simplesub/Typer.scala

// ∩ == intersection
// ∪ == union
//
// https://www.youtube.com/watch?v=d10q-b8jNKg
// x gets type variable A
// y gets type variable B

// union of branches gets type variable C

// constraint: A <= int
// constraint: B <= int
// constraint: A, B <= C

// f: A -> B -> C where A <= int, B <= int, A ∪ B <= C
// then (coalesce bounds)
// f: A ∩ int -> B ∩ int -> A ∪ B ∪ C
// then simplify variables
// f: A ∩ int -> A ∩ int -> A

class SymbolLinks() {
  var typing = false
  var _type: Option<Type> = None
  //    var classId: int = -1
  //    var fieldId: int = -1
  //    var methodId: int = -1
  //    var paramId: int = -1

  def set_type(typ: Type): Type = {
    _type = Some(typ)
    typ
  }

  def has_type(): bool = _type.isDefined

  def get_type(): Type = _type.get
}


// will be connected to a Declaration or an Expression
class NodeLinks() {
  var _symbol: Option<Symbol> = None

  def has_symbol(): bool = _symbol.isDefined

  def get_symbol(): Symbol = _symbol.get

  def set_symbol(symbol: Symbol): Symbol = {
    _symbol = Some(symbol)
    symbol
  }

  var _type: Option<Type> = None

  def has_type(): bool = _type.isDefined

  def get_type(): Type = _type.get

  def set_type(typ: Type): Type = {
    _type = Some(typ)
    typ
  }
}

class TypeLinks() {
  var resolved: bool = false
  var resolving: bool = false
}

//
class Checker(diagnosticBag: DiagnosticBag, root: Symbol, functions: Array<BoundFunction>, fields: Array<BoundField>) {
  var last_symbol_id = 0
  var symbol_links = new Array<SymbolLinks>(10)
  var last_node_id = 0
  var node_links = new Array<NodeLinks>(10)
  var last_type_id = 0
  var type_links = new Array<TypeLinks>(10)
  //
  //    def inferTypes(): unit = {
  //
  //    }

  def check(): unit = {
    // determine types for fields with type annotations
    println("checking field type annotations")
    checkFieldTypeAnnotations()
    // determine types for functions parameters
    println("checking function parameter types and annotated return types")
    checkFunctionParameterTypes()
    // determine types for functions return types & fields without type annotations
    inferFieldTypes()
  }

  def inferFieldTypes(): unit = {
    for (i <- 0 to (fields.length - 1)) {
      val field = fields(i)
      inferFieldType(field)
    }
  }

  def getSymbolType(symbol: Symbol): Option<Type> = {
    val links = getSymbolLinks(symbol)
    if (links.has_type()) {
      Some(links.get_type())
    } else {
      None
    }
  }

  def checkFieldTypeAnnotations(): unit = {
    for (i <- 0 to (fields.length - 1)) {
      val field = fields(i)
      print("checking field type annotation " + field.symbol.fullName() + ": ")
      field.typeAnnotation match {
        case Some(typeAnnotation) =>
          val symbol = field.symbol
          val links = getSymbolLinks(symbol)

          val typ = getTypeOfName(typeAnnotation.typ, symbol.members)
          AstPrinter.printType(typ)
          println()
          links.set_type(typ)
        case None => println()
      }
    }
  }

  def checkFunctionParameterTypes(): unit = {
    for (i <- 0 to (functions.length - 1)) {
      val func = functions(i)
      print("checking function parameter types: " + func.symbol.fullName())
      val parameters = func.parameters
      val typedParameters = new Array<TypedParameter>(parameters.length)
      for (j <- 0 to (parameters.length - 1)) {
        val param = parameters(j)
        val symbol = param.symbol
        val links = getSymbolLinks(symbol)
        val typ = getTypeOfName(param.parameter.typeAnnotation.typ, symbol.members)
        typedParameters(j) = TypedParameter(symbol.name, typ)
        links.set_type(typ)
      }

      func.function.typeAnnotation match {
        case Some(typeAnnotation) =>
          val symbol = func.symbol
          val links = getSymbolLinks(symbol)
          val returnType = getTypeOfName(typeAnnotation.typ, symbol.members)

          val typ = Type.Function(typedParameters, returnType)
          links.set_type(typ)
          AstPrinter.printType(typ)
          println()
        case None =>
          panic(" - no type annotation for function " + func.symbol.fullName())
          println()
      }
    }
  }

  def inferFieldType(field: BoundField): unit = {
    val symbol = field.symbol
    val links = getSymbolLinks(symbol)
    print("inferring type for field " + symbol.fullName() + ": ")
    field.expression match {
      case Some(expression) =>
        val rhs = getTypeOfExpression(expression, symbol.members)
        // if we already have a type here its because the first pass on fields found a type annotation
        if (links.has_type()) {
          val lhs = links.get_type()
          checkAssignable(lhs, rhs)
          AstPrinter.printType(lhs)
        } else {
          links.set_type(rhs)
          AstPrinter.printType(rhs)
        }
        println()
      case None => println()
    }
  }

  def checkAssignable(toType: Type, from: Type): Type = {
    if (toType != from) {
      panic("checkAssignable: " + toType + " != " + from)
      toType
    } else toType
  }

  //
  //    // def fresh_var(): Variable = new Variable(Nothing, Any)
  //
  //    def get_return_type_of_symbol(symbol: Symbol): Type = {
  //        val typ = getTypeOfSymbol(symbol)
  //        getReturnType(typ)
  //    }
  //
  //    def getReturnType(typ: Type): Type = {
  //        if (typ.kind == TypeKind.Function) {
  //            typ.function.get.returnType
  //        } else {
  //            panic("get_return_type expected function kind, found: " + string(typ.kind))
  //            Type.Error
  //        }
  //    }
  //
  //    def resolveTypeConstructor(ctor: TypeConstructor): bool = {
  //        var resolved = true
  //        for (i <- 0 to (ctor.parameters.length-1)) {
  //            resolved = resolved && resolveType(ctor.parameters(i))
  //        }
  //        resolved
  //    }
  //
  //    def resolveFunctionType(func: FunctionType): bool = {
  //        var resolved = true
  //        for (i <- 0 to (func.parameters.length-1)) {
  //            resolved = resolved && resolveType(func.parameters(i))
  //        }
  //        resolved && resolveType(func.returnType)
  //    }
  //
  //    def resolveArrayType(array: ArrayType): bool =
  //        resolveType(array.inner)
  //
  //    def resolveOptionType(option: OptionType): bool =
  //        resolveType(option.inner)
  //
  //    def resolveUnresolvedType(typ: Type): bool = {
  //        val symbol = typ.symbol.get
  //        val resolved = getTypeOfSymbol(symbol)
  //        if (resolved.kind == TypeKind.Unresolved) {
  //            // noop
  //            false
  //        } else {
  //            typ.id = resolved.id
  //            typ.kind = resolved.kind
  //            typ.typeConstructor = resolved.typeConstructor
  ////            typ.intersection = resolved.intersection
  //            typ.primitive = resolved.primitive
  //            typ.typeVariable = resolved.typeVariable
  //            typ.function = resolved.function
  //            typ.array = resolved.array
  //            typ.option = resolved.option
  //            val links = getTypeLinks(typ)
  //            links.resolved
  //        }
  //    }
  //
  //    def getTypeName(typ: Type): string = {
  //        if (typ.kind == TypeKind.Primitive) {
  //            typ.primitive.get.name
  //        } else if (typ.kind == TypeKind.TypeConstructor) {
  //            typ.symbol.get.name
  //        } else if (typ.kind == TypeKind.Array) {
  //            "Array<" + getTypeName(typ.array.get.inner) + ">"
  //        } else if (typ.kind == TypeKind.Option) {
  //            "Option<" + getTypeName(typ.option.get.inner) + ">"
  //        } else if (typ.kind == TypeKind.Function) {
  //            val params = typ.function.get.parameters.map(getTypeName).mkString(", ")
  //            val returnType = getTypeName(typ.function.get.returnType)
  //            s"($params) -> $returnType"
  //        } else {
  //            panic("getTypeName: " + typ.kind)
  //            "unknown"
  //        }
  //    }

  //  def resolveType(typ: Type): bool = {
  //    val links = getTypeLinks(typ)
  //
  //    val start = links.resolved
  //    val resolved = if (links.resolving || links.resolved || typ.kind == TypeKind.Primitive) {
  //      true
  //    } else {
  //      links.resolving = true
  //
  //      if (typ.kind == TypeKind.TypeConstructor) {
  //        resolveTypeConstructor(typ.typeConstructor.get)
  //      } else if (typ.kind == TypeKind.Array) {
  //        resolveArrayType(typ.array.get)
  //      } else if (typ.kind == TypeKind.Option) {
  //        resolveOptionType(typ.option.get)
  //      } else if (typ.kind == TypeKind.Function) {
  //        resolveFunctionType(typ.function.get)
  //      } else if (typ.kind == TypeKind.Unresolved) {
  //        resolveUnresolvedType(typ)
  //      } else {
  //        panic("resolve_type of kind " + string(typ.kind))
  //        false
  //      }
  //    }
  //
  //    if (links.resolved == start) {
  //
  //    } else {
  //      println("type resolved: " + string(links.resolved))
  //    }
  //    links.resolving = false
  //    links.resolved = resolved
  //    resolved
  //  }

  ////    def getTypeOfNode(node: Node): Type = {
  ////        val links = get_node_links(node)
  ////        if (links.has_type()) {
  ////            links.get_type()
  ////        } else if(links.has_symbol()) {
  ////            get_type_of_symbol(links.get_symbol())
  ////        } else {
  ////            // need to find the symbol of this node
  ////
  ////        }
  ////    }
  ////
  ////    def getTypeOfDeclaration(decl: Declaration): Type = {
  ////
  ////    }

  //  def getTypeOfSymbol(symbol: Symbol): Type = {
  //    val links = getSymbolLinks(symbol)
  //    if (links.has_type()) {
  //      links.get_type()
  //    } else if (symbol.has_declaration()) {
  //      val decl = symbol.declaration()
  //      val node_links = get_node_links(MakeNode.decl(decl))
  //      if (node_links.has_type()) {
  //        node_links.get_type()
  //      } else {
  //        if (links.typing) {
  //          // we are already trying to type this symbol so we need to short
  //          // circuit once we get the type we should be able to reattempt
  //          // resolving by updating the unresolved type
  //          MakeType.unresolved(symbol)
  //        } else {
  //          links.typing = true
  //          val typ = getTypeOfDeclaration(decl, symbol.members)
  //          links.typing = false
  //          node_links.set_type(typ)
  //          links.set_type(typ)
  //          print("resolving type for " + symbol.name + "... ")
  //          if (resolveType(typ)) {
  //            AstPrinter.printType(typ)
  //            println()
  //          } else {
  //            AstPrinter.printColor(ColorPalette.Error)
  //            println("failed")
  //            AstPrinter.printClear()
  //          }
  //          typ
  //        }
  //      }
  //    } else {
  //      panic("get_type_of_symbol: no declaration for symbol " + symbol.name)
  //      Type.Error
  //    }
  //  }
  //
  //    def get_type_of_node(node: Node, scope: Scope): Type = {
  //        if (node.is_decl()) {
  //            getTypeOfDeclaration(node.declaration.get, scope)
  //        } else {
  //            getTypeOfExpression(node.expression.get, scope)
  //        }
  //    }
  //
  //    def getTypeOfDeclaration(decl: Declaration, scope: Scope): Type = {
  //        if (decl.kind == DeclarationKind.Object) {
  //            getTypeOfObjectDeclaration(decl.object_declaration.get, scope)
  //        } else if (decl.kind == DeclarationKind.Class) {
  //            get_type_of_class_declaration(decl.class_declaration.get, scope)
  //        } else if (decl.kind == DeclarationKind.Method) {
  //            getTypeOfMethodDeclaration(decl.function_declaration.get, scope)
  //        } else if (decl.kind == DeclarationKind.Parameter) {
  //            get_type_of_parameter_declaration(decl.parameter_declaration.get, scope)
  //        } else if (decl.kind == DeclarationKind.Local) {
  //            get_type_of_local_declaration(decl.local_declaration.get, scope)
  //        } else if (decl.kind == DeclarationKind.Token) {
  //            getTypeOfToken(decl.token_declaration.get, scope)
  //        } else {
  //            panic("get_type_of_declaration")
  //            Type.Error
  //        }
  //    }
  //
  //    def getTypeOfObjectDeclaration(decl: ObjectDeclarationSyntax, scope: Scope): Type = {
  //        val name = scope.name()
  //        //        val fullName = if(name == "") cls.identifier.text else name + "." + cls.identifier.text
  //
  //        MakeType.typeConstructor(scope.parent.symbol.get, new TypeConstructor(name, new Array[Type](0)))
  ////        panic("get_type_of_object_declaration")
  ////        Type.Error
  //    }
  //
  //    def get_type_of_class_declaration(cls: ClassDeclarationSyntax, scope: Scope): Type = {
  //        val name = scope.name()
  ////        val fullName = if(name == "") cls.identifier.text else name + "." + cls.identifier.text
  //
  //        MakeType.typeConstructor(scope.parent.symbol.get, new TypeConstructor(name, new Array[Type](0)))
  //    }
  //
  //    def getTypeOfMethodDeclaration(decl: FunctionDeclarationSyntax, scope: Scope): Type = {
  //        val param_types = new Array[Type](decl.parameters.length)
  //        for (i <- 0 to (decl.parameters.length-1)) {
  //            param_types(i) = get_type_of_parameter_declaration(decl.parameters(i), scope)
  //        }
  //
  //        val returnType = if (decl.typeAnnotation.isDefined) {
  //            get_type_of_type_annotation(decl.typeAnnotation.get, scope)
  //        } else if (decl.body.isDefined) {
  //            getTypeOfExpression(decl.body.get.expression, scope)
  //        } else {
  //            Type.Error
  //        }
  //
  //        MakeType.function(scope.parent.symbol.get, param_types, returnType)
  //    }
  //
  //    def get_type_of_parameter_declaration(decl: ParameterSyntax, scope: Scope): Type =
  //        get_type_of_type_annotation(decl.typeAnnotation, scope)
  //
  //      def get_type_of_local_declaration(decl: VariableDeclarationStatementSyntax, scope: Scope): Type = {
  //          // check type annotation first
  //          if (decl.typeAnnotation.isDefined) {
  //              get_type_of_type_annotation(decl.typeAnnotation.get, scope)
  //          } else {
  //              getTypeOfExpression(decl.expression, scope)
  //          }
  //      }

  def getTypeOfExpression(expr: ExpressionSyntax, scope: Scope): Type = {
    expr match {
      case ExpressionSyntax.ArrayCreationExpression(value) => getTypeOfArrayCreationExpression(value, scope)
      case ExpressionSyntax.AssignmentExpression(value) => getTypeOfAssignmentExpression(value, scope)
      case ExpressionSyntax.BinaryExpression(value) => getTypeOfBinaryExpression(value, scope)
      case ExpressionSyntax.BlockExpression(value) => getTypeOfBlockExpression(value, scope)
      case ExpressionSyntax.CallExpression(value) => getTypeOfCallExpression(value, scope)
      case ExpressionSyntax.ForExpression(value) => getTypeOfForExpression(value, scope)
      case ExpressionSyntax.GroupExpression(value) => getTypeOfGroupExpression(value, scope)
      case ExpressionSyntax.IdentifierName(value) => getTypeOfIdentifierName(value, scope)
      case ExpressionSyntax.IfExpression(value) => getTypeOfIfExpression(value, scope)
      case ExpressionSyntax.IndexExpression(value) => getTypeOfIndexExpression(value, scope)
      case ExpressionSyntax.LiteralExpression(value) => getTypeOfLiteralExpression(value, scope)
      case ExpressionSyntax.MemberAccessExpression(value) => getTypeOfMemberAccessExpression(value, scope)
      case expr: ExpressionSyntax.MatchExpression => getTypeOfMatchExpression(expr, scope)
      case ExpressionSyntax.NewExpression(value) => getTypeOfNewExpression(value, scope)
      case ExpressionSyntax.UnaryExpression(value) => getTypeOfUnaryExpression(value, scope)
      case ExpressionSyntax.UnitExpression(value) => getTypeOfUnitExpression(value, scope)
      case ExpressionSyntax.WhileExpression(value) => getTypeOfWhileExpression(value, scope)
    }
  }

  def getTypeOfArrayCreationExpression(value: ArrayCreationExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfAssignmentExpression(value: AssignmentExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfBinaryExpression(value: BinaryExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfBlockExpression(value: BlockExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfCallExpression(value: CallExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfForExpression(value: ForExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfGroupExpression(value: GroupExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfIdentifierName(value: SimpleNameSyntax.IdentifierNameSyntax, scope: Scope): Type = {
    scope.get(value.identifier.text) match {
      case Some(symbol) =>
        val links = getSymbolLinks(symbol)
        if (links.has_type()) {
          links.get_type()
        } else {
          // TODO: need to resolve type manually

          // maybe the binder should track all items that define a declaration rather than specific types
          // we can build Nodes that represent the declaration and then we can track the type of the node
          // as well as the symbol that the node is associated with


          panic(symbol.location.to_string() + " getTypeOfIdentifierName: no type for symbol " + symbol.fullName())
          Type.Error
        }
      case None =>
        diagnosticBag.reportTypeNotDefined(value.identifier.location, value.identifier.text)
        Type.Error
    }
    //    AstPrinter.printTokenInfo(value.identifier)
    //    panic("todo")
  }

  def getTypeOfIfExpression(value: IfExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfIndexExpression(value: IndexExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfLiteralExpression(value: LiteralExpressionSyntax, scope: Scope): Type = {
    value.value.kind match {
      case SyntaxTokenValueKind.string => Type.string
      case SyntaxTokenValueKind.Number => Type.int
      case SyntaxTokenValueKind.bool => Type.bool
      case SyntaxTokenValueKind.Character => Type.Char
      case _ => panic("getTypeOfLiteralExpression: " + value.value.kind)
    }
  }

  def getTypeOfMemberAccessExpression(value: MemberAccessExpressionSyntax, scope: Scope): Type = {
    val left = getTypeOfExpression(value.left, scope)
    left match {
      case Reference(symbol) =>
        symbol.members.get(value.right.identifier.text) match {
          case Some(member) =>
            val links = getSymbolLinks(member)
            if (links.has_type()) {
              links.get_type()
            } else {
              panic("getTypeOfMemberAccessExpression: no type for member " + member.fullName())
              Type.Error
            }
          case None =>
            panic("todo")
            Type.Error
        }
      case _ =>
        panic("todo")
    }
  } 
    

  def getTypeOfMatchExpression(expression: ExpressionSyntax.MatchExpression, scope: Scope): Type = panic("todo")

  def getTypeOfNewExpression(value: NewExpressionSyntax, scope: Scope): Type =
    getTypeOfName(value.name, scope)

  def getTypeOfUnaryExpression(value: UnaryExpressionSyntax, scope: Scope): Type =
    getTypeOfExpression(value.expression, scope)

  def getTypeOfUnitExpression(value: UnitExpressionSyntax, scope: Scope): Type = panic("todo")

  def getTypeOfWhileExpression(value: WhileExpressionSyntax, scope: Scope): Type = panic("todo")

  //
  //    def get_type_of_array_creation_expression(expr: ArrayCreationExpressionSyntax, scope: Scope): Type = {
  //        val inner = get_type_of_name(expr.name, scope)
  //        MakeType.array(inner)
  //    }
  //
  //    def get_type_of_assignment_expression(expr: AssignmentExpressionSyntax, scope: Scope): Type = {
  //        val left = getTypeOfExpression(expr.left, scope)
  //        val right = getTypeOfExpression(expr.right, scope)
  //        if (left == right) {
  //            UnitType
  //        } else {
  //            panic("invalid assignment")
  //            Type.Error
  //        }
  //    }
  //
  //    def getTypeOfBinaryExpression(expr: BinaryExpressionSyntax, scope: Scope): Type = {
  //        val lhs = getTypeOfExpression(expr.left, scope)
  //        val rhs = getTypeOfExpression(expr.right, scope)
  //        val lhsName = getTypeName(lhs)
  //        val rhsName = getTypeName(rhs)
  //        val op = expr.operator.text
  //        val intint = lhsName == "int" && rhsName == "int"
  //        if(intint && (op == "+" || op == "-" || op == "*" || op == "/" || op == "%")) {
  //            lhs
  //        } else {
  //            panic("get_type_of_binary_expression: " + getTypeName(lhs) + " " + expr.operator.text + " " + getTypeName(rhs))
  //            Type.Error
  //        }
  //    }
  //
  //    def getTypeOfBlockExpression(expr: BlockExpressionSyntax, scope: Scope): Type = {
  //        // TODO: we need a better way to grab the block scope that associated to an expression
  //        val block = scope.getScopeByName("block")
  //        if(block.isEmpty) {
  //            panic("getTypeOfBlockExpression: block scope not found")
  //            Type.Error
  //        } else {
  //            val blockScope = block.get
  //            checkStatements(expr.statements, blockScope)
  //            if (expr.expression.isDefined) getTypeOfExpression(expr.expression.get, blockScope)
  //            else UnitType
  //        }
  //    }
  //
  //    def checkStatements(statements: Array[StatementSyntax], scope: Scope) = {
  //        for (i <- 0 to (statements.length-1)) {
  //            checkStatement(statements(i), scope)
  //        }
  //    }
  //
  //    def checkStatement(syntax: StatementSyntax, scope: Scope): unit = {
  //        if (syntax.kind == SyntaxKind.VariableDeclarationStatement) {
  //            checkVariableDeclarationStatement(syntax.variableDeclarationStatement.get, scope)
  //        } else if (syntax.kind == SyntaxKind.ExpressionStatement) {
  //            checkExpressionStatement(syntax.expressionStatement.get, scope)
  //        } else ()
  //    }
  //
  //    def checkExpressionStatement(statement: ExpressionStatementSyntax, scope: Scope): unit = {
  //        getTypeOfExpression(statement.expression, scope)
  //    }
  //
  //    def checkVariableDeclarationStatement(statement: VariableDeclarationStatementSyntax, scope: Scope):unit = {
  //        if (statement.typeAnnotation.isDefined) {
  //            val typ = get_type_of_type_annotation(statement.typeAnnotation.get, scope)
  //            val rhs = getTypeOfExpression(statement.expression, scope)
  //            val symbol = scope.get(statement.identifier.text)
  //            if (symbol.isDefined) {
  //                // verify that rhs matched type annotation
  //                setSymbolType(symbol.get, typ)
  //            } else {
  //                panic("checkVariableDeclarationStatement: symbol not found by binder")
  //            }
  //        } else {
  //            getTypeOfExpression(statement.expression, scope)
  //        }
  //    }
  //
  //    def getTypeOfCallExpression(expr: CallExpressionSyntax, scope: Scope): Type = {
  //        val left = getTypeOfExpression(expr.name, scope)
  //        val arguments = getTypesOfExpressionList(expr.arguments, scope)
  //
  //        if (left.kind == TypeKind.Function) {
  //            val function = left.function.get
  //            val parameters = function.parameters
  //            if (parameters.length == arguments.length) {
  //                var error = false
  //                var i = 0
  //                 while(i < parameters.length - 1) {
  //                     if (parameters(i) != arguments(i)) {
  //                         error = true
  //                     } else ()
  //                     i = i + 1
  //                 }
  //                if (error) {
  //                    panic("getTypeOfCallExpression: parameter mismatch")
  //                    return Type.Error
  //                } else {
  //                    function.returnType
  //                }
  //            } else {
  //                panic("getTypeOfCallExpression: parameter count mismatch")
  //                Type.Error
  //            }
  //        } else if (left.kind == TypeKind.Array) {
  //            // confirm only one argument
  //            if (arguments.length != 1) {
  //                panic("getTypeOfCallExpression: array method expects one argument")
  //                Type.Error
  //            } else {
  //                val arg = arguments(0)
  //                if (arg != IntType) {
  //                    panic("getTypeOfCallExpression: array method expects int argument")
  //                } else {
  //                    left.array.get.inner
  //                }
  //            }
  //        } else {
  //            panic("expected function type, found: " + getTypeName(left))
  //            Type.Error
  //        }
  //    }
  //
  //    def getTypesOfExpressionList(arguments: ExpressionListSyntax, scope: Scope): Array[Type] = {
  //        val types = new Array[Type](arguments.expressions.length)
  //        for (i <- 0 to (arguments.expressions.length-1)) {
  //            types(i) =            getTypeOfExpression(arguments.expressions(i).expression, scope)
  //        }
  //        types
  //    }
  //
  //    def getTypeOfForExpression(expr: ForExpressionSyntax, scope: Scope): Type = {
  //        // TODO: this only supports one for loop in a given method currently
  //        val maybeForScope = scope.getScopeByName("for")
  //        if(maybeForScope.isEmpty) {
  //            panic("getTypeOfForExpression: for scope not found")
  //            Type.Error
  //        } else {
  //            val forScope = maybeForScope.get
  //            val variable = expr.identifier.text
  //
  //            val symbol = forScope.get(variable)
  //            if(symbol.isEmpty) {
  //                panic("getTypeOfForExpression: symbol not found")
  //                Type.Error
  //            } else {
  //                setSymbolType(symbol.get, IntType)
  //
  //                getTypeOfExpression(expr.fromExpr, forScope)
  //                getTypeOfExpression(expr.toExpr, forScope)
  //                getTypeOfExpression(expr.body, forScope)
  //
  //                UnitType
  //            }
  //        }
  //    }
  //    def get_type_of_group_expression(expr: GroupExpressionSyntax, scope: Scope): Type =
  //        getTypeOfExpression(expr.expression, scope)
  //
  //    def getTypeOfIdentifierName(expr: IdentifierNameSyntax, scope: Scope): Type =
  //        getTypeOfToken(expr.identifier, scope)
  //
  //    def getTypeOfIfExpression(expr: IfExpressionSyntax, scope: Scope): Type = {
  //        val lhs = getTypeOfExpression(expr.thenExpr, scope)
  //        val rhs = getTypeOfExpression(expr.elseExpr, scope)
  //        if(lhs == rhs) lhs
  //        else {
  //            panic("get_type_of_if_expression")
  //            Type.Error
  //        }
  //    }
  //    def get_type_of_index_expression(expr: IndexExpressionSyntax): Type = {
  //        panic("get_type_of_index_expression")
  //        Type.Error
  //    }
  //    def get_type_of_literal_expression(expr: LiteralExpressionSyntax): Type = {
  //        if (expr.value.kind == SyntaxTokenValueKind.Boolean) BoolType
  //        else if (expr.value.kind == SyntaxTokenValueKind.String) StringType
  //        else if (expr.value.kind == SyntaxTokenValueKind.Character) CharType
  //        else if (expr.value.kind == SyntaxTokenValueKind.Number) IntType
  //        else {
  //            panic("get_type_of_literal_expression of kind: " + string(expr.value.kind))
  //            Type.Error
  //        }
  //    }
  //
  //    def getTypeOfMemberAccessExpression(expr: MemberAccessExpressionSyntax, scope: Scope): Type = {
  //        val left = getTypeOfExpression(expr.left, scope)
  //        // special cases
  //        // 1. option
  //        // 2. array
  //        val memberName = expr.right.identifier.text
  //        if(left.kind == TypeKind.Option) {
  //            if(memberName == "get") {
  //                left.option.get.inner
  //            } else {
  //                panic("getTypeOfMemberAccessExpression: unknown member " + memberName)
  //                Type.Error
  //            }
  //        } else if (left.kind == TypeKind.Array) {
  //            if(memberName == "length") {
  //                IntType
  //            } else {
  //                panic("getTypeOfMemberAccessExpression: unknown member " + memberName)
  //                Type.Error
  //            }
  //
  //        } else {
  //            val method = left.symbol.get.members.get(memberName)
  //            if(method.isDefined) getTypeOfSymbol(method.get)
  //            else {
  //                panic("getTypeOfMemberAccessExpression")
  //                Type.Error
  //            }
  //        }
  //    }
  //
  //    def get_type_of_new_expression(expr: NewExpressionSyntax, scope: Scope): Type =
  //        get_type_of_name(expr.name, scope)
  //
  //    def get_type_of_unary_expression(expr: UnaryExpressionSyntax, scope: Scope): Type = {
  //        val rhs = getTypeOfExpression(expr.expression, scope)
  //        if (expr.operator.text == "-") {
  //            if (rhs.kind == TypeKind.Primitive && rhs.primitive.get.name == "int") {
  //                IntType
  //            } else if (rhs.kind == TypeKind.Primitive) {
  //                printLocation(expr.operator.location)
  //                panic("get_type_of_unary_expression: unknown primitive " + rhs.primitive.get.name)
  //                Type.Error
  //            } else {
  //                panic("get_type_of_unary_expression: unknown rhs.kind " + string(rhs.kind))
  //                Type.Error
  //            }
  //        } else {
  //            panic("get_type_of_unary_expression: unknown operator " + expr.operator.text)
  //            Type.Error
  //        }
  //    }
  //
  //    def get_type_of_unit_expression(expr: UnitExpressionSyntax): Type = {
  //        panic("get_type_of_unit_expression")
  //        Type.Error
  //    }
  //
  //    def get_type_of_while_expression(expr: WhileExpressionSyntax): Type = {
  //        panic("get_type_of_while_expression")
  //        Type.Error
  //    }
  //
  //    def get_type_of_type_annotation(typ: TypeAnnotationSyntax, scope: Scope): Type =
  //        get_type_of_name(typ.typ, scope)

  def getTypeOfToken(token: SyntaxToken, scope: Scope): Type =
    getTypeOfString(token.text, token.location, scope)

  def getTypeOfString(name: string, location: TextLocation, scope: Scope): Type = {
    val scalaType = if (location.source_file.isScala()) {
      if (name == "String") {
        Type.string
      } else if (name == "Int") {
        Type.int
      } else if (name == "Char") {
        Type.Char
      } else if (name == "Boolean") {
        Type.bool
      } else if (name == "Unit") {
        Type.unit
      } else {
        Type.Error
      }
    } else Type.Error

    if (scalaType != Type.Error) {
      scalaType
    } else if (name == "int") {
      Type.int
    } else if (name == "char") {
      Type.Char
    } else if (name == "string") {
      Type.string
    } else if (name == "bool") {
      Type.bool
    } else if (name == "any") {
      Type.Any
    } else if (name == "unit") {
      Type.unit
    } else {
      val result = scope.get(name)
      if (result.isDefined) {
        Type.Reference(result.get)
      } else {
        diagnosticBag.reportTypeNotDefined(location, name)
        Type.Error
      }
    }
  }

  def getTypeOfName(name: NameSyntax, scope: Scope): Type = {
    name match {
      case NameSyntax.SimpleName(name) =>
        getTypeOfSimpleName(name, scope)
      case NameSyntax.QualifiedNameSyntax(left, dotToken, right) =>
        getTypeOfQualifiedName(left, dotToken, right, scope)
    }
  }

  def getTypeOfSimpleName(name: SimpleNameSyntax, scope: Scope): Type = {
    name match {
      case SimpleNameSyntax.GenericNameSyntax(identifier, typeArgumentList) =>
        getTypeOfGenericName(identifier, typeArgumentList, scope)
      case SimpleNameSyntax.IdentifierNameSyntax(identifier) =>
        getTypeOfToken(identifier, scope)
      case _: SimpleNameSyntax.AliasSyntax => ???
      case _: SimpleNameSyntax.ScalaAliasSyntax => ???
    }
  }

  def getTypeOfGenericName(identifier: SyntaxToken,
                           typeArgumentlist: TypeArgumentListSyntax, scope: Scope): Type = {
    if (identifier.text == "Array") {
      if (typeArgumentlist.arguments.length == 1) {
        val inner = getTypeOfName(typeArgumentlist.arguments(0).name, scope)
        Type.Array(inner)
      } else {
        panic("Expected Array of rank 1, found rank " + string(typeArgumentlist.arguments.length))
        Type.Error
      }
    } else if (identifier.text == "Option") {
      if (typeArgumentlist.arguments.length == 1) {
        val inner = getTypeOfName(typeArgumentlist.arguments(0).name, scope)
        Type.Option(inner)
      } else {
        panic("Expected Option with one type parameter, found " + string(typeArgumentlist.arguments.length))
        Type.Error
      }
    } else {
      panic("Expected Array, found: '" + identifier.text + "'")
      Type.Error
    }
  }

  def getTypeOfQualifiedName(left: NameSyntax, dotToken: SyntaxToken, right: SimpleNameSyntax, scope: Scope): Type = {
    val leftType = getTypeOfName(left, scope)
    leftType match {
      case Type.Reference(symbol) =>
        getTypeOfSimpleName(right, symbol.members)
      case Type.Error => Type.Error
      case _ => panic("Expected reference type, found: " + leftType)
    }
  }
  //
  //    def get_type_of_class_symbol(symbol: Symbol): Type = {
  //        panic("get_type_of_class_symbol")
  //        Type.Error
  //    }
  //    def get_type_of_method_symbol(symbol: Symbol): Type = {
  //        panic("get_type_of_method_symbol")
  //        Type.Error
  //    }
  //    def get_type_of_field_symbol(symbol: Symbol): Type = {
  //        panic("get_type_of_field_symbol")
  //        Type.Error
  //    }
  //    def get_type_of_parameter_symbol(symbol: Symbol): Type = {
  //        panic("get_type_of_parameter_symbol")
  //        Type.Error
  //    }
  //    def get_type_of_local_symbol(symbol: Symbol): Type = {
  //        panic("get_type_of_local_symbol")
  //        Type.Error
  //    }
  //
  //
  //  def get_node_id(node: Node): int = {
  //    if (node.id() != -1) {
  //      node.id()
  //    } else {
  //      if (last_node_id + 1 >= node_links.length) {
  //        val newItems = new Array[NodeLinks]((last_node_id + 1) * 2)
  //        for (i <- 0 to (last_node_id - 1)) {
  //          newItems(i) = node_links(i)
  //        }
  //        node_links = newItems
  //      } else {}
  //
  //      node_links(last_node_id) = new NodeLinks()
  //      node.set_id(last_node_id)
  //      last_node_id = last_node_id + 1
  //      node.id()
  //    }
  //  }

  //  def get_node_links(node: Node): NodeLinks = {
  //    val id = get_node_id(node)
  //    node_links(id)
  //  }


  //  def get_type_id(typ: Type): int = {
  //    if (typ.id != -1) {
  //      typ.id
  //    } else {
  //      if (last_type_id + 1 >= type_links.length) {
  //        val newItems = new Array[TypeLinks]((last_type_id + 1) * 2)
  //        for (i <- 0 to (last_type_id - 1)) {
  //          newItems(i) = type_links(i)
  //        }
  //        type_links = newItems
  //      } else {}
  //
  //      type_links(last_type_id) = new TypeLinks()
  //      typ.id = last_type_id
  //      last_type_id = last_type_id + 1
  //      typ.id
  //    }
  //  }

  //  def getTypeLinks(typ: Type): TypeLinks = {
  //    val id = get_type_id(typ)
  //    type_links(id)
  //  }

  def get_symbol_id(symbol: Symbol): int = {
    if (symbol.id != -1) {
      symbol.id
    } else {
      if (last_symbol_id + 1 >= symbol_links.length) {
        val newItems = new Array<SymbolLinks>((last_symbol_id + 1) * 2)
        for (i <- 0 to (last_symbol_id - 1)) {
          newItems(i) = symbol_links(i)
        }
        symbol_links = newItems
      } else {}

      symbol_links(last_symbol_id) = new SymbolLinks()
      symbol.id = last_symbol_id
      last_symbol_id = last_symbol_id + 1
      symbol.id
    }
  }

  def getSymbolLinks(symbol: Symbol): SymbolLinks = {
    val id = get_symbol_id(symbol)
    symbol_links(id)
  }
  //
  //
  //    def printLocation(location: TextLocation): unit = {
  //        val span = location.span
  //        val source_file = location.source_file
  //
  //        for (currrent_line <- location.start_line to location.end_line) {
  //            val line = source_file.get_line(currrent_line)
  //            val start_in_current = source_file.get_line_index(span.start) == currrent_line
  //            val end_in_current = source_file.get_line_index(span.end) == currrent_line
  //
  //            val prefix_end =
  //                if (start_in_current) span.start
  //                else line.start
  //
  //            val suffix_start =
  //                if (end_in_current) span.end
  //                else line.end
  //
  //            val prefix_span = TextSpanFactory.from_bounds(line.start, prefix_end)
  //            val error_span = TextSpanFactory.from_bounds(prefix_end, suffix_start)
  //            val suffix_span = TextSpanFactory.from_bounds(suffix_start, line.end)
  //
  //            val prefix = source_file.to_string(prefix_span)
  //            val error = source_file.to_string(error_span)
  //            val suffix = source_file.to_string(suffix_span)
  //
  //            print(prefix)
  //            print(ANSI.foreground_color("e06c75"))
  //            print(error)
  //            print(ANSI.Clear)
  //            println(suffix)
  //
  //            for(c <- 0 to (prefix_span.length - 1)) {
  //                print('-')
  //            }
  //            println('^')
  //        }
  //
  //        println()
  //    }
  //
  //    // // convert an inferred SimpleType into the immutable type representation
  //    // def coalesce_type(simple: SimpleType): Type =
  //    //     coalesce_type(simple, true)
  //
  //    // def coalesce_type(simple: SimpleType, polarity: bool): Type = {
  //    //     if (simple.kind == SimpleTypeKind.Variable) {
  //    //         val tv = simple.variable[0]
  //    //         val bound = if (polarity) tv.lower_bound() else tv.upper_bound()
  //    //         val bound_type = coalesce_type(bound, polarity)
  //    //         if (polarity && bound.is_nothing() || bound.is_any()) tv.as_type_var()
  //    //         else if (polarity) MakeType.union(tv.as_type_var(), bound_type)
  //    //         else MakeType.intersection(tv.as_type_var(), bound_type)
  //    //     } else {
  //    //         val concrete = simple.concrete[0]
  //    //         if (concrete.kind == ConcreteTypeKind.Function) {
  //    //             MakeType.function(
  //    //                 concrete.function[0].symbol,
  //    //                 coalesce_types(concrete.function[0].params, !polarity),
  //    //                 coalesce_type(concrete.function[0].returnType, polarity)
  //    //             )
  //    //         } else if (concrete.kind == ConcreteTypeKind.Record) {
  //    //             MakeType.record(concrete.record[0].symbol, coalesce_record(concrete.record[0], polarity))
  //    //         } else if (concrete.kind == ConcreteTypeKind.Primitive) {
  //    //             MakeType.primitive(concrete.primitive[0].name)
  //    //         } else if (concrete.kind == ConcreteTypeKind.Any) {
  //    //             MakeType.top
  //    //         } else // if (concrete.kind == ConcreteTypeKind.Nothing) {
  //    //             MakeType.bottom
  //    //         }
  //    // }
  //
  //    // def coalesce_types(simple_types: Array[SimpleType], polarity: bool): Array[Type] = {
  //    //     val types = new Type[simple_types.length]
  //    //     for (x <- 0 to simple_types.length) {
  //    //         types(x) = coalesce_type(simple_types(x), polarity)
  //    //     }
  //    //     types
  //    // }
  //
  //    // def coalesce_record(record: Record, polarity: bool): RecordType = {
  //    //     val fields = new RecordTypeField[record.fields.length]
  //    //     for (x <- 0 to record.fields.length) {
  //    //         fields(x) = coalesce_record_field(record.fields(x), polarity)
  //    //     }
  //    //     new RecordType(fields)
  //    // }
  //
  //    // def coalesce_record_field(field: RecordField, polarity: bool): RecordTypeField =
  //    //     new RecordTypeField(field.name, coalesce_type(field.type, polarity))
  //
  //    def initBuiltins() = {
  //        val args = new Array[Type](1)
  //        args(0) = StringType
  //
  //        val println = new Symbol(SymbolKind.Method, SymbolFlags.Static, "println", TextLocationFactory.empty(), None)
  //        val message = new Symbol(SymbolKind.Parameter, SymbolFlags.None, "message", TextLocationFactory.empty(), None)
  //        println.members.addSymbol(message)
  //        root.members.addSymbol(println)
  //
  //        setSymbolType(message, StringType)
  //        setSymbolType(println, MakeType.function(println, args, UnitType))
  //
  //        val print = new Symbol(SymbolKind.Method, SymbolFlags.Static, "print", TextLocationFactory.empty(), None)
  //        val message1 = new Symbol(SymbolKind.Parameter, SymbolFlags.None, "message", TextLocationFactory.empty(), None)
  //        print.members.addSymbol(message1)
  //        root.members.addSymbol(print)
  //
  //        setSymbolType(message1, StringType)
  //        setSymbolType(print, MakeType.function(print, args, UnitType))
  //    }
  //
  //    def setSymbolType(symbol: Symbol, value: Type) = {
  //        val links = getSymbolLinks(symbol)
  //        links.set_type(value)
  //    }
}